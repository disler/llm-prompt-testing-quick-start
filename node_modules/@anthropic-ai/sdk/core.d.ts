import { APIError } from './error.js';
import type { Readable } from '@anthropic-ai/sdk/_shims/node-readable';
import { type Agent } from '@anthropic-ai/sdk/_shims/agent';
import { type RequestInfo, type RequestInit, type Response } from '@anthropic-ai/sdk/_shims/fetch';
export {
  maybeMultipartFormRequestOptions,
  multipartFormRequestOptions,
  createForm,
  type Uploadable,
} from './uploads.js';
export type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;
export declare abstract class APIClient {
  baseURL: string;
  maxRetries: number;
  timeout: number;
  httpAgent: Agent | undefined;
  private fetch;
  protected idempotencyHeader?: string;
  constructor({
    baseURL,
    maxRetries,
    timeout, // 60s
    httpAgent,
    fetch: overridenFetch,
  }: {
    baseURL: string;
    maxRetries?: number | undefined;
    timeout: number | undefined;
    httpAgent: Agent | undefined;
    fetch: Fetch | undefined;
  });
  protected authHeaders(): Headers;
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  protected defaultHeaders(): Headers;
  protected abstract defaultQuery(): DefaultQuery | undefined;
  /**
   * Override this to add your own headers validation:
   */
  protected validateHeaders(headers: Headers, customHeaders: Headers): void;
  protected defaultIdempotencyKey(): string;
  get<Req extends {}, Rsp>(path: string, opts?: RequestOptions<Req>): Promise<Rsp>;
  post<Req extends {}, Rsp>(path: string, opts?: RequestOptions<Req>): Promise<Rsp>;
  patch<Req extends {}, Rsp>(path: string, opts?: RequestOptions<Req>): Promise<Rsp>;
  put<Req extends {}, Rsp>(path: string, opts?: RequestOptions<Req>): Promise<Rsp>;
  delete<Req extends {}, Rsp>(path: string, opts?: RequestOptions<Req>): Promise<Rsp>;
  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(
    path: string,
    Page: new (...args: any[]) => PageClass,
    opts?: RequestOptions<any>,
  ): PagePromise<PageClass>;
  private calculateContentLength;
  buildRequest<Req extends {}>(
    options: FinalRequestOptions<Req>,
  ): {
    req: RequestInit;
    url: string;
    timeout: number;
  };
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  protected prepareRequest(
    request: RequestInit,
    {
      url,
    }: {
      url: string;
    },
  ): Promise<void>;
  protected makeStatusError(
    status: number | undefined,
    error: Object | undefined,
    message: string | undefined,
    headers: Headers | undefined,
  ): APIError;
  request<Req extends {}, Rsp>(
    options: FinalRequestOptions<Req>,
    retriesRemaining?: number,
  ): Promise<APIResponse<Rsp>>;
  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(
    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,
    options: FinalRequestOptions,
  ): PagePromise<PageClass>;
  buildURL<Req>(path: string, query: Req | undefined): string;
  protected stringifyQuery(query: Record<string, unknown>): string;
  fetchWithTimeout(
    url: RequestInfo,
    init: RequestInit | undefined,
    ms: number,
    controller: AbortController,
  ): Promise<Response>;
  protected getRequestClient(): RequestClient;
  private shouldRetry;
  private retryRequest;
  private calculateRetryTimeoutSeconds;
  private getUserAgent;
  private debug;
}
export declare class APIResource {
  protected client: APIClient;
  constructor(client: APIClient);
  protected get: APIClient['get'];
  protected post: APIClient['post'];
  protected patch: APIClient['patch'];
  protected put: APIClient['put'];
  protected delete: APIClient['delete'];
  protected getAPIList: APIClient['getAPIList'];
}
export type PageInfo =
  | {
      url: URL;
    }
  | {
      params: Record<string, unknown> | null;
    };
export declare abstract class AbstractPage<Item> implements AsyncIterable<Item> {
  #private;
  protected options: FinalRequestOptions;
  constructor(client: APIClient, response: APIResponse<unknown>, options: FinalRequestOptions);
  /**
   * @deprecated Use nextPageInfo instead
   */
  abstract nextPageParams(): Partial<Record<string, unknown>> | null;
  abstract nextPageInfo(): PageInfo | null;
  abstract getPaginatedItems(): Item[];
  hasNextPage(): boolean;
  getNextPage(): Promise<AbstractPage<Item>>;
  iterPages(): AsyncGenerator<AbstractPage<Item>, void, unknown>;
  [Symbol.asyncIterator](): AsyncGenerator<Awaited<Item>, void, unknown>;
}
export declare class PagePromise<
    PageClass extends AbstractPage<Item>,
    Item = ReturnType<PageClass['getPaginatedItems']>[number],
  >
  extends Promise<PageClass>
  implements AsyncIterable<Item>
{
  /**
   * This subclass of Promise will resolve to an instantiated Page once the request completes.
   */
  constructor(
    client: APIClient,
    requestPromise: Promise<APIResponse<unknown>>,
    options: FinalRequestOptions,
    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,
  );
  /**
   * Enable subclassing Promise.
   * Ref: https://stackoverflow.com/a/60328122
   */
  static get [Symbol.species](): PromiseConstructor;
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  [Symbol.asyncIterator](): AsyncGenerator<Awaited<Item>, void, unknown>;
}
export declare const createResponseHeaders: (
  headers: Awaited<ReturnType<Fetch>>['headers'],
) => Record<string, string>;
type HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';
export type RequestClient = {
  fetch: Fetch;
};
export type Headers = Record<string, string | null | undefined>;
export type DefaultQuery = Record<string, string | undefined>;
export type KeysEnum<T> = {
  [P in keyof Required<T>]: true;
};
export type RequestOptions<Req extends {} = Record<string, unknown> | Readable> = {
  method?: HTTPMethod;
  path?: string;
  query?: Req | undefined;
  body?: Req | undefined;
  headers?: Headers | undefined;
  maxRetries?: number;
  stream?: boolean | undefined;
  timeout?: number;
  httpAgent?: Agent;
  signal?: AbortSignal | undefined | null;
  idempotencyKey?: string;
};
export declare const isRequestOptions: (
  obj: unknown,
) => obj is RequestOptions<Readable | Record<string, unknown>>;
export type FinalRequestOptions<Req extends {} = Record<string, unknown> | Readable> = RequestOptions<Req> & {
  method: HTTPMethod;
  path: string;
};
export type APIResponse<T> = T & {
  /** @deprecated - we plan to add a different way to access raw response information shortly. */
  responseHeaders: Headers;
};
export declare const safeJSON: (text: string) => any;
export declare const castToError: (err: any) => Error;
export declare const ensurePresent: <T>(value: T | null | undefined) => T;
/**
 * Read an environment variable.
 *
 * Will return an empty string if the environment variable doesn't exist or cannot be accessed.
 */
export declare const readEnv: (env: string) => string | undefined;
export declare const coerceInteger: (value: unknown) => number;
export declare const coerceFloat: (value: unknown) => number;
export declare const coerceBoolean: (value: unknown) => boolean;
export declare const maybeCoerceInteger: (value: unknown) => number | undefined;
export declare const maybeCoerceFloat: (value: unknown) => number | undefined;
export declare const maybeCoerceBoolean: (value: unknown) => boolean | undefined;
export declare function isEmptyObj(obj: Object | null | undefined): boolean;
export declare function hasOwn(obj: Object, key: string): boolean;
export interface HeadersProtocol {
  get: (header: string) => string | null | undefined;
}
export type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;
export declare const isHeadersProtocol: (headers: any) => headers is HeadersProtocol;
export declare const getHeader: (headers: HeadersLike, key: string) => string | null | undefined;
/**
 * Encodes a string to Base64 format.
 */
export declare const toBase64: (str: string | null | undefined) => string;
//# sourceMappingURL=core.d.ts.map
