{"version":3,"file":"index.js","sources":["../src/pipeline.ts","../src/log.ts","../src/util/sanitizer.ts","../src/policies/logPolicy.ts","../src/policies/redirectPolicy.ts","../src/util/userAgentPlatform.ts","../src/constants.ts","../src/util/userAgent.ts","../src/policies/userAgentPolicy.ts","../src/util/typeGuards.ts","../src/util/file.ts","../src/util/concat.ts","../src/policies/multipartPolicy.ts","../src/policies/decompressResponsePolicy.ts","../src/util/helpers.ts","../src/retryStrategies/throttlingRetryStrategy.ts","../src/retryStrategies/exponentialRetryStrategy.ts","../src/policies/retryPolicy.ts","../src/policies/defaultRetryPolicy.ts","../src/httpHeaders.ts","../src/policies/formDataPolicy.ts","../src/policies/proxyPolicy.ts","../src/policies/setClientRequestIdPolicy.ts","../src/policies/tlsPolicy.ts","../src/util/inspect.ts","../src/restError.ts","../src/policies/tracingPolicy.ts","../src/createPipelineFromOptions.ts","../src/nodeHttpClient.ts","../src/defaultHttpClient.ts","../src/pipelineRequest.ts","../src/policies/exponentialRetryPolicy.ts","../src/policies/systemErrorRetryPolicy.ts","../src/policies/throttlingRetryPolicy.ts","../src/util/tokenCycler.ts","../src/policies/bearerTokenAuthenticationPolicy.ts","../src/policies/ndJsonPolicy.ts","../src/policies/auxiliaryAuthenticationHeaderPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { HttpClient, PipelineRequest, PipelineResponse, SendRequest } from \"./interfaces\";\n\n/**\n * Policies are executed in phases.\n * The execution order is:\n * 1. Serialize Phase\n * 2. Policies not in a phase\n * 3. Deserialize Phase\n * 4. Retry Phase\n * 5. Sign Phase\n */\nexport type PipelinePhase = \"Deserialize\" | \"Serialize\" | \"Retry\" | \"Sign\";\n\nconst ValidPhaseNames = new Set<PipelinePhase>([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n\n/**\n * Options when adding a policy to the pipeline.\n * Used to express dependencies on other policies.\n */\nexport interface AddPolicyOptions {\n  /**\n   * Policies that this policy must come before.\n   */\n  beforePolicies?: string[];\n  /**\n   * Policies that this policy must come after.\n   */\n  afterPolicies?: string[];\n  /**\n   * The phase that this policy must come after.\n   */\n  afterPhase?: PipelinePhase;\n  /**\n   * The phase this policy belongs to.\n   */\n  phase?: PipelinePhase;\n}\n\n/**\n * A pipeline policy manipulates a request as it travels through the pipeline.\n * It is conceptually a middleware that is allowed to modify the request before\n * it is made as well as the response when it is received.\n */\nexport interface PipelinePolicy {\n  /**\n   * The policy name. Must be a unique string in the pipeline.\n   */\n  name: string;\n  /**\n   * The main method to implement that manipulates a request/response.\n   * @param request - The request being performed.\n   * @param next - The next policy in the pipeline. Must be called to continue the pipeline.\n   */\n  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;\n}\n\n/**\n * Represents a pipeline for making a HTTP request to a URL.\n * Pipelines can have multiple policies to manage manipulating each request\n * before and after it is made to the server.\n */\nexport interface Pipeline {\n  /**\n   * Add a new policy to the pipeline.\n   * @param policy - A policy that manipulates a request.\n   * @param options - A set of options for when the policy should run.\n   */\n  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;\n  /**\n   * Remove a policy from the pipeline.\n   * @param options - Options that let you specify which policies to remove.\n   */\n  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];\n  /**\n   * Uses the pipeline to make a HTTP request.\n   * @param httpClient - The HttpClient that actually performs the request.\n   * @param request - The request to be made.\n   */\n  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;\n  /**\n   * Returns the current set of policies in the pipeline in the order in which\n   * they will be applied to the request. Later in the list is closer to when\n   * the request is performed.\n   */\n  getOrderedPolicies(): PipelinePolicy[];\n  /**\n   * Duplicates this pipeline to allow for modifying an existing one without mutating it.\n   */\n  clone(): Pipeline;\n}\n\ninterface PipelineDescriptor {\n  policy: PipelinePolicy;\n  options: AddPolicyOptions;\n}\n\ninterface PolicyGraphNode {\n  policy: PipelinePolicy;\n  dependsOn: Set<PolicyGraphNode>;\n  dependants: Set<PolicyGraphNode>;\n  afterPhase?: Phase;\n}\n\ninterface Phase {\n  name: PipelinePhase | \"None\";\n  policies: Set<PolicyGraphNode>;\n  hasRun: boolean;\n  hasAfterPolicies: boolean;\n}\n\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline implements Pipeline {\n  private _policies: PipelineDescriptor[] = [];\n  private _orderedPolicies?: PipelinePolicy[];\n\n  private constructor(policies?: PipelineDescriptor[]) {\n    this._policies = policies?.slice(0) ?? [];\n    this._orderedPolicies = undefined;\n  }\n\n  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options,\n    });\n    this._orderedPolicies = undefined;\n  }\n\n  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {\n    const removedPolicies: PipelinePolicy[] = [];\n\n    this._policies = this._policies.filter((policyDescriptor) => {\n      if (\n        (options.name && policyDescriptor.policy.name === options.name) ||\n        (options.phase && policyDescriptor.options.phase === options.phase)\n      ) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n\n    return removedPolicies;\n  }\n\n  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {\n    const policies = this.getOrderedPolicies();\n\n    const pipeline = policies.reduceRight<SendRequest>(\n      (next, policy) => {\n        return (req: PipelineRequest) => {\n          return policy.sendRequest(req, next);\n        };\n      },\n      (req: PipelineRequest) => httpClient.sendRequest(req),\n    );\n\n    return pipeline(request);\n  }\n\n  public getOrderedPolicies(): PipelinePolicy[] {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n\n  public clone(): Pipeline {\n    return new HttpPipeline(this._policies);\n  }\n\n  public static create(): Pipeline {\n    return new HttpPipeline();\n  }\n\n  private orderPolicies(): PipelinePolicy[] {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result: PipelinePolicy[] = [];\n\n    // Track all policies we know about.\n    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();\n\n    function createPhase(name: PipelinePhase | \"None\"): Phase {\n      return {\n        name,\n        policies: new Set<PolicyGraphNode>(),\n        hasRun: false,\n        hasAfterPolicies: false,\n      };\n    }\n\n    // Track policies for each phase.\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\");\n\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n\n    // Small helper function to map phase name to each Phase\n    function getPhase(phase: PipelinePhase | undefined): Phase {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    }\n\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node: PolicyGraphNode = {\n        policy,\n        dependsOn: new Set<PolicyGraphNode>(),\n        dependants: new Set<PolicyGraphNode>(),\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    }\n\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const { policy, options } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase: Phase): void {\n      phase.hasRun = true;\n      // Sets iterate in insertion order\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n\n    function walkPhases(): void {\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        // if the phase isn't complete\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    }\n\n    // Iterate until we've put every node in the result list.\n    let iteration = 0;\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline(): Pipeline {\n  return HttpPipeline.create();\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-rest-pipeline\");\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { type UnknownObject, isObject } from \"@azure/core-util\";\n\n/**\n * @internal\n */\nexport interface SanitizerOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n}\n\nconst RedactedString = \"REDACTED\";\n\n// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts\nconst defaultAllowedHeaderNames = [\n  \"x-ms-client-request-id\",\n  \"x-ms-return-client-request-id\",\n  \"x-ms-useragent\",\n  \"x-ms-correlation-request-id\",\n  \"x-ms-request-id\",\n  \"client-request-id\",\n  \"ms-cv\",\n  \"return-client-request-id\",\n  \"traceparent\",\n\n  \"Access-Control-Allow-Credentials\",\n  \"Access-Control-Allow-Headers\",\n  \"Access-Control-Allow-Methods\",\n  \"Access-Control-Allow-Origin\",\n  \"Access-Control-Expose-Headers\",\n  \"Access-Control-Max-Age\",\n  \"Access-Control-Request-Headers\",\n  \"Access-Control-Request-Method\",\n  \"Origin\",\n\n  \"Accept\",\n  \"Accept-Encoding\",\n  \"Cache-Control\",\n  \"Connection\",\n  \"Content-Length\",\n  \"Content-Type\",\n  \"Date\",\n  \"ETag\",\n  \"Expires\",\n  \"If-Match\",\n  \"If-Modified-Since\",\n  \"If-None-Match\",\n  \"If-Unmodified-Since\",\n  \"Last-Modified\",\n  \"Pragma\",\n  \"Request-Id\",\n  \"Retry-After\",\n  \"Server\",\n  \"Transfer-Encoding\",\n  \"User-Agent\",\n  \"WWW-Authenticate\",\n];\n\nconst defaultAllowedQueryParameters: string[] = [\"api-version\"];\n\n/**\n * @internal\n */\nexport class Sanitizer {\n  private allowedHeaderNames: Set<string>;\n  private allowedQueryParameters: Set<string>;\n\n  constructor({\n    additionalAllowedHeaderNames: allowedHeaderNames = [],\n    additionalAllowedQueryParameters: allowedQueryParameters = [],\n  }: SanitizerOptions = {}) {\n    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);\n    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);\n\n    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));\n    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));\n  }\n\n  public sanitize(obj: unknown): string {\n    const seen = new Set<unknown>();\n    return JSON.stringify(\n      obj,\n      (key: string, value: unknown) => {\n        // Ensure Errors include their interesting non-enumerable members\n        if (value instanceof Error) {\n          return {\n            ...value,\n            name: value.name,\n            message: value.message,\n          };\n        }\n\n        if (key === \"headers\") {\n          return this.sanitizeHeaders(value as UnknownObject);\n        } else if (key === \"url\") {\n          return this.sanitizeUrl(value as string);\n        } else if (key === \"query\") {\n          return this.sanitizeQuery(value as UnknownObject);\n        } else if (key === \"body\") {\n          // Don't log the request body\n          return undefined;\n        } else if (key === \"response\") {\n          // Don't log response again\n          return undefined;\n        } else if (key === \"operationSpec\") {\n          // When using sendOperationRequest, the request carries a massive\n          // field with the autorest spec. No need to log it.\n          return undefined;\n        } else if (Array.isArray(value) || isObject(value)) {\n          if (seen.has(value)) {\n            return \"[Circular]\";\n          }\n          seen.add(value);\n        }\n\n        return value;\n      },\n      2,\n    );\n  }\n\n  private sanitizeHeaders(obj: UnknownObject): UnknownObject {\n    const sanitized: UnknownObject = {};\n    for (const key of Object.keys(obj)) {\n      if (this.allowedHeaderNames.has(key.toLowerCase())) {\n        sanitized[key] = obj[key];\n      } else {\n        sanitized[key] = RedactedString;\n      }\n    }\n    return sanitized;\n  }\n\n  private sanitizeQuery(value: UnknownObject): UnknownObject {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    const sanitized: UnknownObject = {};\n\n    for (const k of Object.keys(value)) {\n      if (this.allowedQueryParameters.has(k.toLowerCase())) {\n        sanitized[k] = value[k];\n      } else {\n        sanitized[k] = RedactedString;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private sanitizeUrl(value: string): string {\n    if (typeof value !== \"string\" || value === null) {\n      return value;\n    }\n\n    const url = new URL(value);\n\n    if (!url.search) {\n      return value;\n    }\n\n    for (const [key] of url.searchParams) {\n      if (!this.allowedQueryParameters.has(key.toLowerCase())) {\n        url.searchParams.set(key, RedactedString);\n      }\n    }\n\n    return url.toString();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { Debugger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { logger as coreLogger } from \"../log\";\nimport { Sanitizer } from \"../util/sanitizer\";\n\n/**\n * The programmatic identifier of the logPolicy.\n */\nexport const logPolicyName = \"logPolicy\";\n\n/**\n * Options to configure the logPolicy.\n */\nexport interface LogPolicyOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n\n  /**\n   * The log function to use for writing pipeline logs.\n   * Defaults to core-http's built-in logger.\n   * Compatible with the `debug` library.\n   */\n  logger?: Debugger;\n}\n\n/**\n * A policy that logs all requests and responses.\n * @param options - Options to configure logPolicy.\n */\nexport function logPolicy(options: LogPolicyOptions = {}): PipelinePolicy {\n  const logger = options.logger ?? coreLogger.info;\n  const sanitizer = new Sanitizer({\n    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,\n    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n  });\n  return {\n    name: logPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!logger.enabled) {\n        return next(request);\n      }\n\n      logger(`Request: ${sanitizer.sanitize(request)}`);\n\n      const response = await next(request);\n\n      logger(`Response status code: ${response.status}`);\n      logger(`Headers: ${sanitizer.sanitize(response.headers)}`);\n\n      return response;\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport const redirectPolicyName = \"redirectPolicy\";\n\n/**\n * Methods that are allowed to follow redirects 301 and 302\n */\nconst allowedRedirect = [\"GET\", \"HEAD\"];\n\n/**\n * Options for how redirect responses are handled.\n */\nexport interface RedirectPolicyOptions {\n  /**\n   * The maximum number of times the redirect URL will be tried before\n   * failing.  Defaults to 20.\n   */\n  maxRetries?: number;\n}\n\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * In the browser, this policy is not used.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy(options: RedirectPolicyOptions = {}): PipelinePolicy {\n  const { maxRetries = 20 } = options;\n  return {\n    name: redirectPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return handleRedirect(next, response, maxRetries);\n    },\n  };\n}\n\nasync function handleRedirect(\n  next: SendRequest,\n  response: PipelineResponse,\n  maxRetries: number,\n  currentRetries: number = 0,\n): Promise<PipelineResponse> {\n  const { request, status, headers } = response;\n  const locationHeader = headers.get(\"location\");\n  if (\n    locationHeader &&\n    (status === 300 ||\n      (status === 301 && allowedRedirect.includes(request.method)) ||\n      (status === 302 && allowedRedirect.includes(request.method)) ||\n      (status === 303 && request.method === \"POST\") ||\n      status === 307) &&\n    currentRetries < maxRetries\n  ) {\n    const url = new URL(locationHeader, request.url);\n    request.url = url.toString();\n\n    // POST request with Status code 303 should be converted into a\n    // redirected GET request if the redirect url is present in the location header\n    if (status === 303) {\n      request.method = \"GET\";\n      request.headers.delete(\"Content-Length\");\n      delete request.body;\n    }\n\n    request.headers.delete(\"Authorization\");\n\n    const res = await next(request);\n    return handleRedirect(next, res, maxRetries, currentRetries + 1);\n  }\n\n  return response;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as os from \"os\";\n\n/**\n * @internal\n */\nexport function getHeaderName(): string {\n  return \"User-Agent\";\n}\n\n/**\n * @internal\n */\nexport function setPlatformSpecificData(map: Map<string, string>): void {\n  map.set(\"Node\", process.version);\n  map.set(\"OS\", `(${os.arch()}-${os.type()}-${os.release()})`);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const SDK_VERSION: string = \"1.14.0\";\n\nexport const DEFAULT_RETRY_POLICY_COUNT = 3;\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { getHeaderName, setPlatformSpecificData } from \"./userAgentPlatform\";\nimport { SDK_VERSION } from \"../constants\";\n\nfunction getUserAgentString(telemetryInfo: Map<string, string>): string {\n  const parts: string[] = [];\n  for (const [key, value] of telemetryInfo) {\n    const token = value ? `${key}/${value}` : key;\n    parts.push(token);\n  }\n  return parts.join(\" \");\n}\n\n/**\n * @internal\n */\nexport function getUserAgentHeaderName(): string {\n  return getHeaderName();\n}\n\n/**\n * @internal\n */\nexport function getUserAgentValue(prefix?: string): string {\n  const runtimeInfo = new Map<string, string>();\n  runtimeInfo.set(\"core-rest-pipeline\", SDK_VERSION);\n  setPlatformSpecificData(runtimeInfo);\n  const defaultAgent = getUserAgentString(runtimeInfo);\n  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;\n  return userAgentValue;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { getUserAgentHeaderName, getUserAgentValue } from \"../util/userAgent\";\n\nconst UserAgentHeaderName = getUserAgentHeaderName();\n\n/**\n * The programmatic identifier of the userAgentPolicy.\n */\nexport const userAgentPolicyName = \"userAgentPolicy\";\n\n/**\n * Options for adding user agent details to outgoing requests.\n */\nexport interface UserAgentPolicyOptions {\n  /**\n   * String prefix to add to the user agent for outgoing requests.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A policy that sets the User-Agent header (or equivalent) to reflect\n * the library version.\n * @param options - Options to customize the user agent value.\n */\nexport function userAgentPolicy(options: UserAgentPolicyOptions = {}): PipelinePolicy {\n  const userAgentValue = getUserAgentValue(options.userAgentPrefix);\n  return {\n    name: userAgentPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(UserAgentHeaderName)) {\n        request.headers.set(UserAgentHeaderName, userAgentValue);\n      }\n      return next(request);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport function isNodeReadableStream(x: unknown): x is NodeJS.ReadableStream {\n  return Boolean(x && typeof (x as NodeJS.ReadableStream)[\"pipe\"] === \"function\");\n}\n\nexport function isWebReadableStream(x: unknown): x is ReadableStream {\n  return Boolean(\n    x &&\n      typeof (x as ReadableStream).getReader === \"function\" &&\n      typeof (x as ReadableStream).tee === \"function\",\n  );\n}\n\nexport function isReadableStream(x: unknown): x is ReadableStream | NodeJS.ReadableStream {\n  return isNodeReadableStream(x) || isWebReadableStream(x);\n}\n\nexport function isBlob(x: unknown): x is Blob {\n  return typeof (x as Blob).stream === \"function\";\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isNode } from \"@azure/core-util\";\nimport { isNodeReadableStream } from \"./typeGuards\";\n\n/**\n * Options passed into createFile specifying metadata about the file.\n */\nexport interface CreateFileOptions {\n  /**\n   * The MIME type of the file.\n   */\n  type?: string;\n\n  /**\n   * Last modified time of the file as a UNIX timestamp.\n   * This will default to the current date.\n   */\n  lastModified?: number;\n\n  /**\n   * relative path of this file when uploading a directory.\n   */\n  webkitRelativePath?: string;\n}\n\n/**\n * Extra options for createFile when a stream is being passed in.\n */\nexport interface CreateFileFromStreamOptions extends CreateFileOptions {\n  /**\n   * Size of the file represented by the stream in bytes.\n   *\n   * This will be used by the pipeline when calculating the Content-Length header\n   * for the overall request.\n   */\n  size?: number;\n}\n\nconst unimplementedMethods = {\n  arrayBuffer: () => {\n    throw new Error(\"Not implemented\");\n  },\n  slice: () => {\n    throw new Error(\"Not implemented\");\n  },\n  text: () => {\n    throw new Error(\"Not implemented\");\n  },\n};\n\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent: unique symbol = Symbol(\"rawContent\");\n\n/**\n * Type signature of a blob-like object with a raw content property.\n */\ninterface RawContent {\n  [rawContent](): Uint8Array | NodeJS.ReadableStream | ReadableStream<Uint8Array>;\n}\n\nfunction hasRawContent(x: unknown): x is RawContent {\n  return typeof (x as RawContent)[rawContent] === \"function\";\n}\n\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the blob's content as a Web ReadableStream<Uint8Array>.\n *\n * @internal\n */\nexport function getRawContent(\n  blob: Blob,\n): NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array {\n  if (hasRawContent(blob)) {\n    return blob[rawContent]();\n  } else {\n    return blob.stream();\n  }\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(\n  stream: () => ReadableStream<Uint8Array> | NodeJS.ReadableStream,\n  name: string,\n  options: CreateFileFromStreamOptions = {},\n): File {\n  return {\n    ...unimplementedMethods,\n    type: options.type ?? \"\",\n    lastModified: options.lastModified ?? new Date().getTime(),\n    webkitRelativePath: options.webkitRelativePath ?? \"\",\n    size: options.size ?? -1,\n    name,\n    stream: () => {\n      const s = stream();\n      if (isNodeReadableStream(s)) {\n        throw new Error(\n          \"Not supported: a Node stream was provided as input to createFileFromStream.\",\n        );\n      }\n\n      return s;\n    },\n    [rawContent]: stream,\n  } as File & RawContent;\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(\n  content: Uint8Array,\n  name: string,\n  options: CreateFileOptions = {},\n): File {\n  if (isNode) {\n    return {\n      ...unimplementedMethods,\n      type: options.type ?? \"\",\n      lastModified: options.lastModified ?? new Date().getTime(),\n      webkitRelativePath: options.webkitRelativePath ?? \"\",\n      size: content.byteLength,\n      name,\n      arrayBuffer: async () => content.buffer,\n      stream: () => new Blob([content]).stream(),\n      [rawContent]: () => content,\n    } as File & RawContent;\n  } else {\n    return new File([content], name, options);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Readable } from \"stream\";\nimport type { ReadableStream as AsyncIterableReadableStream } from \"stream/web\";\nimport { isBlob } from \"./typeGuards\";\nimport { getRawContent } from \"./file\";\n\nasync function* streamAsyncIterator(\n  this: ReadableStream<Uint8Array>,\n): AsyncIterableIterator<Uint8Array> {\n  const reader = this.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nfunction makeAsyncIterable<T>(webStream: any): asserts webStream is AsyncIterableReadableStream<T> {\n  if (!webStream[Symbol.asyncIterator]) {\n    webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);\n  }\n\n  if (!webStream.values) {\n    webStream.values = streamAsyncIterator.bind(webStream);\n  }\n}\n\nfunction ensureNodeStream(\n  stream: ReadableStream<Uint8Array> | NodeJS.ReadableStream,\n): NodeJS.ReadableStream {\n  if (stream instanceof ReadableStream) {\n    makeAsyncIterable<Uint8Array>(stream);\n    return Readable.fromWeb(stream);\n  } else {\n    return stream;\n  }\n}\n\nfunction toStream(\n  source: ReadableStream<Uint8Array> | NodeJS.ReadableStream | Uint8Array | Blob,\n): NodeJS.ReadableStream {\n  if (source instanceof Uint8Array) {\n    return Readable.from(Buffer.from(source));\n  } else if (isBlob(source)) {\n    return toStream(getRawContent(source));\n  } else {\n    return ensureNodeStream(source);\n  }\n}\n\n/**\n * Accepted binary data types for concat\n *\n * @internal\n */\nexport type ConcatSource = ReadableStream<Uint8Array> | NodeJS.ReadableStream | Uint8Array | Blob;\n\n/**\n * Utility function that concatenates a set of binary inputs into one combined output.\n *\n * @param sources - array of sources for the concatenation\n * @returns - in Node, a (() =\\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.\n *           In browser, returns a `Blob` representing all the concatenated inputs.\n *\n * @internal\n */\nexport async function concat(\n  sources: (ConcatSource | (() => ConcatSource))[],\n): Promise<(() => NodeJS.ReadableStream) | Blob> {\n  return function () {\n    const streams = sources.map((x) => (typeof x === \"function\" ? x() : x)).map(toStream);\n\n    return Readable.from(\n      (async function* () {\n        for (const stream of streams as NodeJS.ReadableStream[]) {\n          for await (const chunk of stream) {\n            yield chunk;\n          }\n        }\n      })(),\n    );\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { randomUUID, stringToUint8Array } from \"@azure/core-util\";\nimport type { BodyPart, HttpHeaders, PipelineRequest, PipelineResponse } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { concat } from \"../util/concat\";\nimport { isBlob } from \"../util/typeGuards\";\n\nfunction generateBoundary(): string {\n  return `----AzSDKFormBoundary${randomUUID()}`;\n}\n\nfunction encodeHeaders(headers: HttpHeaders): string {\n  let result = \"\";\n  for (const [key, value] of headers) {\n    result += `${key}: ${value}\\r\\n`;\n  }\n  return result;\n}\n\nfunction getLength(\n  source:\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream,\n): number | undefined {\n  if (source instanceof Uint8Array) {\n    return source.byteLength;\n  } else if (isBlob(source)) {\n    // if was created using createFile then -1 means we have an unknown size\n    return source.size === -1 ? undefined : source.size;\n  } else {\n    return undefined;\n  }\n}\n\nfunction getTotalLength(\n  sources: (\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream\n  )[],\n): number | undefined {\n  let total = 0;\n  for (const source of sources) {\n    const partLength = getLength(source);\n    if (partLength === undefined) {\n      return undefined;\n    } else {\n      total += partLength;\n    }\n  }\n  return total;\n}\n\nasync function buildRequestBody(\n  request: PipelineRequest,\n  parts: BodyPart[],\n  boundary: string,\n): Promise<void> {\n  const sources = [\n    stringToUint8Array(`--${boundary}`, \"utf-8\"),\n    ...parts.flatMap((part) => [\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"),\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      part.body,\n      stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\"),\n    ]),\n    stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\"),\n  ];\n\n  const contentLength = getTotalLength(sources);\n  if (contentLength) {\n    request.headers.set(\"Content-Length\", contentLength);\n  }\n\n  request.body = await concat(sources);\n}\n\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = \"multipartPolicy\";\n\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(\n  `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`,\n);\n\nfunction assertValidBoundary(boundary: string): void {\n  if (boundary.length > maxBoundaryLength) {\n    throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n  }\n\n  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {\n    throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n  }\n}\n\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy(): PipelinePolicy {\n  return {\n    name: multipartPolicyName,\n    async sendRequest(request, next): Promise<PipelineResponse> {\n      if (!request.multipartBody) {\n        return next(request);\n      }\n\n      if (request.body) {\n        throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n      }\n\n      let boundary = request.multipartBody.boundary;\n\n      const contentTypeHeader = request.headers.get(\"Content-Type\") ?? \"multipart/mixed\";\n      const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n      if (!parsedHeader) {\n        throw new Error(\n          `Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`,\n        );\n      }\n\n      const [, contentType, parsedBoundary] = parsedHeader;\n      if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n        throw new Error(\n          `Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`,\n        );\n      }\n\n      boundary ??= parsedBoundary;\n      if (boundary) {\n        assertValidBoundary(boundary);\n      } else {\n        boundary = generateBoundary();\n      }\n      request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n      await buildRequestBody(request, request.multipartBody.parts, boundary);\n\n      request.multipartBody = undefined;\n\n      return next(request);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the decompressResponsePolicy.\n */\nexport const decompressResponsePolicyName = \"decompressResponsePolicy\";\n\n/**\n * A policy to enable response decompression according to Accept-Encoding header\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding\n */\nexport function decompressResponsePolicy(): PipelinePolicy {\n  return {\n    name: decompressResponsePolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      // HEAD requests have no body\n      if (request.method !== \"HEAD\") {\n        request.headers.set(\"Accept-Encoding\", \"gzip,deflate\");\n      }\n      return next(request);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError, type AbortSignalLike } from \"@azure/abort-controller\";\nimport type { PipelineResponse } from \"../interfaces\";\n\nconst StandardAbortMessage = \"The operation was aborted.\";\n\n/**\n * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @param options - The options for delay - currently abort options\n *                  - abortSignal - The abortSignal associated with containing operation.\n *                  - abortErrorMsg - The abort error message associated with containing operation.\n * @returns Resolved promise\n */\nexport function delay<T>(\n  delayInMs: number,\n  value?: T,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    abortErrorMsg?: string;\n  },\n): Promise<T | void> {\n  return new Promise((resolve, reject) => {\n    let timer: ReturnType<typeof setTimeout> | undefined = undefined;\n    let onAborted: (() => void) | undefined = undefined;\n\n    const rejectOnAbort = (): void => {\n      return reject(\n        new AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage),\n      );\n    };\n\n    const removeListeners = (): void => {\n      if (options?.abortSignal && onAborted) {\n        options.abortSignal.removeEventListener(\"abort\", onAborted);\n      }\n    };\n\n    onAborted = (): void => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      removeListeners();\n      return rejectOnAbort();\n    };\n\n    if (options?.abortSignal && options.abortSignal.aborted) {\n      return rejectOnAbort();\n    }\n\n    timer = setTimeout(() => {\n      removeListeners();\n      resolve(value);\n    }, delayInMs);\n\n    if (options?.abortSignal) {\n      options.abortSignal.addEventListener(\"abort\", onAborted);\n    }\n  });\n}\n\n/**\n * @internal\n * @returns the parsed value or undefined if the parsed value is invalid.\n */\nexport function parseHeaderValueAsNumber(\n  response: PipelineResponse,\n  headerName: string,\n): number | undefined {\n  const value = response.headers.get(headerName);\n  if (!value) return;\n  const valueAsNum = Number(value);\n  if (Number.isNaN(valueAsNum)) return;\n  return valueAsNum;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineResponse } from \"..\";\nimport { parseHeaderValueAsNumber } from \"../util/helpers\";\nimport type { RetryStrategy } from \"./retryStrategy\";\n\n/**\n * The header that comes back from Azure services representing\n * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).\n */\nconst RetryAfterHeader = \"Retry-After\";\n/**\n * The headers that come back from Azure services representing\n * the amount of time (minimum) to wait to retry.\n *\n * \"retry-after-ms\", \"x-ms-retry-after-ms\" : milliseconds\n * \"Retry-After\" : seconds or timestamp\n */\nconst AllRetryAfterHeaders: string[] = [\"retry-after-ms\", \"x-ms-retry-after-ms\", RetryAfterHeader];\n\n/**\n * A response is a throttling retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n *\n * Returns the `retryAfterInMs` value if the response is a throttling retry response.\n * If not throttling retry response, returns `undefined`.\n *\n * @internal\n */\nfunction getRetryAfterInMs(response?: PipelineResponse): number | undefined {\n  if (!(response && [429, 503].includes(response.status))) return undefined;\n  try {\n    // Headers: \"retry-after-ms\", \"x-ms-retry-after-ms\", \"Retry-After\"\n    for (const header of AllRetryAfterHeaders) {\n      const retryAfterValue = parseHeaderValueAsNumber(response, header);\n      if (retryAfterValue === 0 || retryAfterValue) {\n        // \"Retry-After\" header ==> seconds\n        // \"retry-after-ms\", \"x-ms-retry-after-ms\" headers ==> milli-seconds\n        const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;\n        return retryAfterValue * multiplyingFactor; // in milli-seconds\n      }\n    }\n\n    // RetryAfterHeader (\"Retry-After\") has a special case where it might be formatted as a date instead of a number of seconds\n    const retryAfterHeader = response.headers.get(RetryAfterHeader);\n    if (!retryAfterHeader) return;\n\n    const date = Date.parse(retryAfterHeader);\n    const diff = date - Date.now();\n    // negative diff would mean a date in the past, so retry asap with 0 milliseconds\n    return Number.isFinite(diff) ? Math.max(0, diff) : undefined;\n  } catch (e: any) {\n    return undefined;\n  }\n}\n\n/**\n * A response is a retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n */\nexport function isThrottlingRetryResponse(response?: PipelineResponse): boolean {\n  return Number.isFinite(getRetryAfterInMs(response));\n}\n\nexport function throttlingRetryStrategy(): RetryStrategy {\n  return {\n    name: \"throttlingRetryStrategy\",\n    retry({ response }) {\n      const retryAfterInMs = getRetryAfterInMs(response);\n      if (!Number.isFinite(retryAfterInMs)) {\n        return { skipStrategy: true };\n      }\n      return {\n        retryAfterInMs,\n      };\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineResponse } from \"../interfaces\";\nimport type { RestError } from \"../restError\";\nimport { getRandomIntegerInclusive } from \"@azure/core-util\";\nimport type { RetryStrategy } from \"./retryStrategy\";\nimport { isThrottlingRetryResponse } from \"./throttlingRetryStrategy\";\n\n// intervals are in milliseconds\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;\n\n/**\n * A retry strategy that retries with an exponentially increasing delay in these two cases:\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).\n */\nexport function exponentialRetryStrategy(\n  options: {\n    /**\n     * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n     * (1 second.) The delay increases exponentially with each retry up to a maximum\n     * specified by maxRetryDelayInMs.\n     */\n    retryDelayInMs?: number;\n\n    /**\n     * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n     * to 64000 (64 seconds).\n     */\n    maxRetryDelayInMs?: number;\n\n    /**\n     * If true it won't retry if it received a system error.\n     */\n    ignoreSystemErrors?: boolean;\n\n    /**\n     * If true it won't retry if it received a non-fatal HTTP status code.\n     */\n    ignoreHttpStatusCodes?: boolean;\n  } = {},\n): RetryStrategy {\n  const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;\n  const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n\n  let retryAfterInMs = retryInterval;\n\n  return {\n    name: \"exponentialRetryStrategy\",\n    retry({ retryCount, response, responseError }) {\n      const matchedSystemError = isSystemError(responseError);\n      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;\n\n      const isExponential = isExponentialRetryResponse(response);\n      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;\n      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);\n\n      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {\n        return { skipStrategy: true };\n      }\n\n      if (responseError && !matchedSystemError && !isExponential) {\n        return { errorToThrow: responseError };\n      }\n\n      // Exponentially increase the delay each time\n      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);\n      // Don't let the delay exceed the maximum\n      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);\n      // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n      // that retries across multiple clients don't occur simultaneously.\n      retryAfterInMs =\n        clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n      return { retryAfterInMs };\n    },\n  };\n}\n\n/**\n * A response is a retry response if it has status codes:\n * - 408, or\n * - Greater or equal than 500, except for 501 and 505.\n */\nexport function isExponentialRetryResponse(response?: PipelineResponse): boolean {\n  return Boolean(\n    response &&\n      response.status !== undefined &&\n      (response.status >= 500 || response.status === 408) &&\n      response.status !== 501 &&\n      response.status !== 505,\n  );\n}\n\n/**\n * Determines whether an error from a pipeline response was triggered in the network layer.\n */\nexport function isSystemError(err?: RestError): boolean {\n  if (!err) {\n    return false;\n  }\n  return (\n    err.code === \"ETIMEDOUT\" ||\n    err.code === \"ESOCKETTIMEDOUT\" ||\n    err.code === \"ECONNREFUSED\" ||\n    err.code === \"ECONNRESET\" ||\n    err.code === \"ENOENT\" ||\n    err.code === \"ENOTFOUND\"\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport type { RetryStrategy } from \"../retryStrategies/retryStrategy\";\nimport type { RestError } from \"../restError\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n\n/**\n * Options to the {@link retryPolicy}\n */\nexport interface RetryPolicyOptions {\n  /**\n   * Maximum number of retries. If not specified, it will limit to 3 retries.\n   */\n  maxRetries?: number;\n  /**\n   * Logger. If it's not provided, a default logger is used.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(\n  strategies: RetryStrategy[],\n  options: RetryPolicyOptions = { maxRetries: DEFAULT_RETRY_POLICY_COUNT },\n): PipelinePolicy {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let response: PipelineResponse | undefined;\n      let responseError: RestError | undefined;\n      let retryCount = -1;\n\n      // eslint-disable-next-line no-constant-condition\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e: any) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e as RestError;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n\n          response = responseError.response;\n        }\n\n        if (request.abortSignal?.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n\n        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(\n            `Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`,\n          );\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || retryPolicyLogger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError,\n          });\n\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n\n          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n\n          if (errorToThrow) {\n            strategyLogger.error(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`,\n              errorToThrow,\n            );\n            throw errorToThrow;\n          }\n\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`,\n            );\n            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n            continue retryRequest;\n          }\n\n          if (redirectTo) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`,\n            );\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n\n        if (responseError) {\n          logger.info(\n            `None of the retry strategies could work with the received error. Throwing it.`,\n          );\n          throw responseError;\n        }\n        if (response) {\n          logger.info(\n            `None of the retry strategies could work with the received response. Returning it.`,\n          );\n          return response;\n        }\n\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRetryOptions } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy\";\nimport { throttlingRetryStrategy } from \"../retryStrategies/throttlingRetryStrategy\";\nimport { retryPolicy } from \"./retryPolicy\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\n/**\n * Name of the {@link defaultRetryPolicy}\n */\nexport const defaultRetryPolicyName = \"defaultRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface DefaultRetryPolicyOptions extends PipelineRetryOptions {}\n\n/**\n * A policy that retries according to three strategies:\n * - When the server sends a 429 response with a Retry-After header.\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.\n */\nexport function defaultRetryPolicy(options: DefaultRetryPolicyOptions = {}): PipelinePolicy {\n  return {\n    name: defaultRetryPolicyName,\n    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {\n      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n    }).sendRequest,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { HttpHeaders, RawHttpHeaders, RawHttpHeadersInput } from \"./interfaces\";\n\ninterface HeaderEntry {\n  name: string;\n  value: string;\n}\n\nfunction normalizeName(name: string): string {\n  return name.toLowerCase();\n}\n\nfunction* headerIterator(map: Map<string, HeaderEntry>): IterableIterator<[string, string]> {\n  for (const entry of map.values()) {\n    yield [entry.name, entry.value];\n  }\n}\n\nclass HttpHeadersImpl implements HttpHeaders {\n  private readonly _headersMap: Map<string, HeaderEntry>;\n\n  constructor(rawHeaders?: RawHttpHeaders | RawHttpHeadersInput) {\n    this._headersMap = new Map<string, HeaderEntry>();\n    if (rawHeaders) {\n      for (const headerName of Object.keys(rawHeaders)) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   * @param value - The value of the header to set.\n   */\n  public set(name: string, value: string | number | boolean): void {\n    this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param name - The name of the header. This value is case-insensitive.\n   */\n  public get(name: string): string | undefined {\n    return this._headersMap.get(normalizeName(name))?.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   */\n  public has(name: string): boolean {\n    return this._headersMap.has(normalizeName(name));\n  }\n\n  /**\n   * Remove the header with the provided headerName.\n   * @param name - The name of the header to remove.\n   */\n  public delete(name: string): void {\n    this._headersMap.delete(normalizeName(name));\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJSON(options: { preserveCase?: boolean } = {}): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    if (options.preserveCase) {\n      for (const entry of this._headersMap.values()) {\n        result[entry.name] = entry.value;\n      }\n    } else {\n      for (const [normalizedName, entry] of this._headersMap) {\n        result[normalizedName] = entry.value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJSON({ preserveCase: true }));\n  }\n\n  /**\n   * Iterate over tuples of header [name, value] pairs.\n   */\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return headerIterator(this._headersMap);\n  }\n}\n\n/**\n * Creates an object that satisfies the `HttpHeaders` interface.\n * @param rawHeaders - A simple object representing initial headers\n */\nexport function createHttpHeaders(rawHeaders?: RawHttpHeadersInput): HttpHeaders {\n  return new HttpHeadersImpl(rawHeaders);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { stringToUint8Array } from \"@azure/core-util\";\nimport { createHttpHeaders } from \"../httpHeaders\";\nimport type {\n  BodyPart,\n  FormDataMap,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\n\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy(): PipelinePolicy {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (request.formData) {\n        const contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n          request.body = wwwFormUrlEncode(request.formData);\n        } else {\n          await prepareFormData(request.formData, request);\n        }\n\n        request.formData = undefined;\n      }\n      return next(request);\n    },\n  };\n}\n\nfunction wwwFormUrlEncode(formData: FormDataMap): string {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\n\nasync function prepareFormData(formData: FormDataMap, request: PipelineRequest): Promise<void> {\n  // validate content type (multipart/form-data)\n  const contentType = request.headers.get(\"Content-Type\");\n  if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n    // content type is specified and is not multipart/form-data. Exit.\n    return;\n  }\n\n  request.headers.set(\"Content-Type\", contentType ?? \"multipart/form-data\");\n\n  // set body to MultipartRequestBody using content from FormDataMap\n  const parts: BodyPart[] = [];\n\n  for (const [fieldName, values] of Object.entries(formData)) {\n    for (const value of Array.isArray(values) ? values : [values]) {\n      if (typeof value === \"string\") {\n        parts.push({\n          headers: createHttpHeaders({\n            \"Content-Disposition\": `form-data; name=\"${fieldName}\"`,\n          }),\n          body: stringToUint8Array(value, \"utf-8\"),\n        });\n      } else if (value === undefined || value === null || typeof value !== \"object\") {\n        throw new Error(\n          `Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`,\n        );\n      } else {\n        // using || instead of ?? here since if value.name is empty we should create a file name\n        const fileName = (value as File).name || \"blob\";\n        const headers = createHttpHeaders();\n        headers.set(\n          \"Content-Disposition\",\n          `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`,\n        );\n\n        // again, || is used since an empty value.type means the content type is unset\n        headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n\n        parts.push({\n          headers,\n          body: value,\n        });\n      }\n    }\n  }\n  request.multipartBody = { parts };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type * as http from \"http\";\nimport type * as https from \"https\";\nimport { HttpsProxyAgent, type HttpsProxyAgentOptions } from \"https-proxy-agent\";\nimport { HttpProxyAgent, type HttpProxyAgentOptions } from \"http-proxy-agent\";\nimport type { PipelineRequest, PipelineResponse, ProxySettings, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { logger } from \"../log\";\n\nconst HTTPS_PROXY = \"HTTPS_PROXY\";\nconst HTTP_PROXY = \"HTTP_PROXY\";\nconst ALL_PROXY = \"ALL_PROXY\";\nconst NO_PROXY = \"NO_PROXY\";\n\n/**\n * The programmatic identifier of the proxyPolicy.\n */\nexport const proxyPolicyName = \"proxyPolicy\";\n\n/**\n * Stores the patterns specified in NO_PROXY environment variable.\n * @internal\n */\nexport const globalNoProxyList: string[] = [];\nlet noProxyListLoaded: boolean = false;\n\n/** A cache of whether a host should bypass the proxy. */\nconst globalBypassedMap: Map<string, boolean> = new Map();\n\nfunction getEnvironmentValue(name: string): string | undefined {\n  if (process.env[name]) {\n    return process.env[name];\n  } else if (process.env[name.toLowerCase()]) {\n    return process.env[name.toLowerCase()];\n  }\n  return undefined;\n}\n\nfunction loadEnvironmentProxyValue(): string | undefined {\n  if (!process) {\n    return undefined;\n  }\n\n  const httpsProxy = getEnvironmentValue(HTTPS_PROXY);\n  const allProxy = getEnvironmentValue(ALL_PROXY);\n  const httpProxy = getEnvironmentValue(HTTP_PROXY);\n\n  return httpsProxy || allProxy || httpProxy;\n}\n\n/**\n * Check whether the host of a given `uri` matches any pattern in the no proxy list.\n * If there's a match, any request sent to the same host shouldn't have the proxy settings set.\n * This implementation is a port of https://github.com/Azure/azure-sdk-for-net/blob/8cca811371159e527159c7eb65602477898683e2/sdk/core/Azure.Core/src/Pipeline/Internal/HttpEnvironmentProxy.cs#L210\n */\nfunction isBypassed(\n  uri: string,\n  noProxyList: string[],\n  bypassedMap?: Map<string, boolean>,\n): boolean | undefined {\n  if (noProxyList.length === 0) {\n    return false;\n  }\n  const host = new URL(uri).hostname;\n  if (bypassedMap?.has(host)) {\n    return bypassedMap.get(host);\n  }\n  let isBypassedFlag = false;\n  for (const pattern of noProxyList) {\n    if (pattern[0] === \".\") {\n      // This should match either domain it self or any subdomain or host\n      // .foo.com will match foo.com it self or *.foo.com\n      if (host.endsWith(pattern)) {\n        isBypassedFlag = true;\n      } else {\n        if (host.length === pattern.length - 1 && host === pattern.slice(1)) {\n          isBypassedFlag = true;\n        }\n      }\n    } else {\n      if (host === pattern) {\n        isBypassedFlag = true;\n      }\n    }\n  }\n  bypassedMap?.set(host, isBypassedFlag);\n  return isBypassedFlag;\n}\n\nexport function loadNoProxy(): string[] {\n  const noProxy = getEnvironmentValue(NO_PROXY);\n  noProxyListLoaded = true;\n  if (noProxy) {\n    return noProxy\n      .split(\",\")\n      .map((item) => item.trim())\n      .filter((item) => item.length);\n  }\n\n  return [];\n}\n\n/**\n * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.\n * If no argument is given, it attempts to parse a proxy URL from the environment\n * variables `HTTPS_PROXY` or `HTTP_PROXY`.\n * @param proxyUrl - The url of the proxy to use. May contain authentication information.\n */\nexport function getDefaultProxySettings(proxyUrl?: string): ProxySettings | undefined {\n  if (!proxyUrl) {\n    proxyUrl = loadEnvironmentProxyValue();\n    if (!proxyUrl) {\n      return undefined;\n    }\n  }\n\n  const parsedUrl = new URL(proxyUrl);\n  const schema = parsedUrl.protocol ? parsedUrl.protocol + \"//\" : \"\";\n  return {\n    host: schema + parsedUrl.hostname,\n    port: Number.parseInt(parsedUrl.port || \"80\"),\n    username: parsedUrl.username,\n    password: parsedUrl.password,\n  };\n}\n\n/**\n * @internal\n */\nexport function getProxyAgentOptions(\n  proxySettings: ProxySettings,\n  { headers, tlsSettings }: PipelineRequest,\n): HttpProxyAgentOptions {\n  let parsedProxyUrl: URL;\n  try {\n    parsedProxyUrl = new URL(proxySettings.host);\n  } catch (_error) {\n    throw new Error(\n      `Expecting a valid host string in proxy settings, but found \"${proxySettings.host}\".`,\n    );\n  }\n\n  if (tlsSettings) {\n    logger.warning(\n      \"TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.\",\n    );\n  }\n\n  const proxyAgentOptions: HttpsProxyAgentOptions = {\n    hostname: parsedProxyUrl.hostname,\n    port: proxySettings.port,\n    protocol: parsedProxyUrl.protocol,\n    headers: headers.toJSON(),\n  };\n  if (proxySettings.username && proxySettings.password) {\n    proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}`;\n  } else if (proxySettings.username) {\n    proxyAgentOptions.auth = `${proxySettings.username}`;\n  }\n  return proxyAgentOptions;\n}\n\nfunction setProxyAgentOnRequest(request: PipelineRequest, cachedAgents: CachedAgents): void {\n  // Custom Agent should take precedence so if one is present\n  // we should skip to avoid overwriting it.\n  if (request.agent) {\n    return;\n  }\n\n  const url = new URL(request.url);\n\n  const isInsecure = url.protocol !== \"https:\";\n\n  const proxySettings = request.proxySettings;\n  if (proxySettings) {\n    if (isInsecure) {\n      if (!cachedAgents.httpProxyAgent) {\n        const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);\n        cachedAgents.httpProxyAgent = new HttpProxyAgent(proxyAgentOptions);\n      }\n      request.agent = cachedAgents.httpProxyAgent;\n    } else {\n      if (!cachedAgents.httpsProxyAgent) {\n        const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);\n        cachedAgents.httpsProxyAgent = new HttpsProxyAgent(proxyAgentOptions);\n      }\n      request.agent = cachedAgents.httpsProxyAgent;\n    }\n  }\n}\n\ninterface CachedAgents {\n  httpsProxyAgent?: https.Agent;\n  httpProxyAgent?: http.Agent;\n}\n\n/**\n * A policy that allows one to apply proxy settings to all requests.\n * If not passed static settings, they will be retrieved from the HTTPS_PROXY\n * or HTTP_PROXY environment variables.\n * @param proxySettings - ProxySettings to use on each request.\n * @param options - additional settings, for example, custom NO_PROXY patterns\n */\nexport function proxyPolicy(\n  proxySettings = getDefaultProxySettings(),\n  options?: {\n    /** a list of patterns to override those loaded from NO_PROXY environment variable. */\n    customNoProxyList?: string[];\n  },\n): PipelinePolicy {\n  if (!noProxyListLoaded) {\n    globalNoProxyList.push(...loadNoProxy());\n  }\n\n  const cachedAgents: CachedAgents = {};\n\n  return {\n    name: proxyPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (\n        !request.proxySettings &&\n        !isBypassed(\n          request.url,\n          options?.customNoProxyList ?? globalNoProxyList,\n          options?.customNoProxyList ? undefined : globalBypassedMap,\n        )\n      ) {\n        request.proxySettings = proxySettings;\n      }\n\n      if (request.proxySettings) {\n        setProxyAgentOnRequest(request, cachedAgents);\n      }\n      return next(request);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the setClientRequestIdPolicy.\n */\nexport const setClientRequestIdPolicyName = \"setClientRequestIdPolicy\";\n\n/**\n * Each PipelineRequest gets a unique id upon creation.\n * This policy passes that unique id along via an HTTP header to enable better\n * telemetry and tracing.\n * @param requestIdHeaderName - The name of the header to pass the request ID to.\n */\nexport function setClientRequestIdPolicy(\n  requestIdHeaderName = \"x-ms-client-request-id\",\n): PipelinePolicy {\n  return {\n    name: setClientRequestIdPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(requestIdHeaderName)) {\n        request.headers.set(requestIdHeaderName, request.requestId);\n      }\n      return next(request);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelinePolicy } from \"../pipeline\";\nimport type { TlsSettings } from \"../interfaces\";\n\n/**\n * Name of the TLS Policy\n */\nexport const tlsPolicyName = \"tlsPolicy\";\n\n/**\n * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.\n */\nexport function tlsPolicy(tlsSettings?: TlsSettings): PipelinePolicy {\n  return {\n    name: tlsPolicyName,\n    sendRequest: async (req, next) => {\n      // Users may define a request tlsSettings, honor those over the client level one\n      if (!req.tlsSettings) {\n        req.tlsSettings = tlsSettings;\n      }\n      return next(req);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { inspect } from \"util\";\n\nexport const custom = inspect.custom;\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isError } from \"@azure/core-util\";\nimport type { PipelineRequest, PipelineResponse } from \"./interfaces\";\nimport { custom } from \"./util/inspect\";\nimport { Sanitizer } from \"./util/sanitizer\";\n\nconst errorSanitizer = new Sanitizer();\n\n/**\n * The options supported by RestError.\n */\nexport interface RestErrorOptions {\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  statusCode?: number;\n  /**\n   * The request that was made.\n   */\n  request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   */\n  response?: PipelineResponse;\n}\n\n/**\n * A custom error type for failed pipeline requests.\n */\nexport class RestError extends Error {\n  /**\n   * Something went wrong when making the request.\n   * This means the actual request failed for some reason,\n   * such as a DNS issue or the connection being lost.\n   */\n  static readonly REQUEST_SEND_ERROR: string = \"REQUEST_SEND_ERROR\";\n  /**\n   * This means that parsing the response from the server failed.\n   * It may have been malformed.\n   */\n  static readonly PARSE_ERROR: string = \"PARSE_ERROR\";\n\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  public code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  public statusCode?: number;\n  /**\n   * The request that was made.\n   */\n  public request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   */\n  public response?: PipelineResponse;\n  /**\n   * Bonus property set by the throw site.\n   */\n  public details?: unknown;\n\n  constructor(message: string, options: RestErrorOptions = {}) {\n    super(message);\n    this.name = \"RestError\";\n    this.code = options.code;\n    this.statusCode = options.statusCode;\n    this.request = options.request;\n    this.response = options.response;\n\n    Object.setPrototypeOf(this, RestError.prototype);\n  }\n\n  /**\n   * Logging method for util.inspect in Node\n   */\n  [custom](): string {\n    return `RestError: ${this.message} \\n ${errorSanitizer.sanitize(this)}`;\n  }\n}\n\n/**\n * Typeguard for RestError\n * @param e - Something caught by a catch clause.\n */\nexport function isRestError(e: unknown): e is RestError {\n  if (e instanceof RestError) {\n    return true;\n  }\n  return isError(e) && e.name === \"RestError\";\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  type TracingClient,\n  type TracingContext,\n  type TracingSpan,\n  createTracingClient,\n} from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError\";\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  const tracingClient = tryCreateTracingClient();\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!tracingClient || !request.tracingOptions?.tracingContext) {\n        return next(request);\n      }\n\n      const { span, tracingContext } = tryCreateSpan(tracingClient, request, userAgent) ?? {};\n\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err: any) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    },\n  };\n}\n\nfunction tryCreateTracingClient(): TracingClient | undefined {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION,\n    });\n  } catch (e: unknown) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryCreateSpan(\n  tracingClient: TracingClient,\n  request: PipelineRequest,\n  userAgent?: string,\n): { span: TracingSpan; tracingContext: TracingContext } | undefined {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const { span, updatedOptions } = tracingClient.startSpan(\n      `HTTP ${request.method}`,\n      { tracingOptions: request.tracingOptions },\n      {\n        spanKind: \"client\",\n        spanAttributes: {\n          \"http.method\": request.method,\n          \"http.url\": request.url,\n          requestId: request.requestId,\n        },\n      },\n    );\n\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n\n    // set headers\n    const headers = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions.tracingContext,\n    );\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n  } catch (e: any) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span: TracingSpan, error: unknown): void {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined,\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n\nfunction tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\",\n    });\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { type LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport { type Pipeline, createEmptyPipeline } from \"./pipeline\";\nimport type { PipelineRetryOptions, TlsSettings, ProxySettings } from \"./interfaces\";\nimport { type RedirectPolicyOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { type UserAgentPolicyOptions, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { multipartPolicy, multipartPolicyName } from \"./policies/multipartPolicy\";\nimport { decompressResponsePolicy } from \"./policies/decompressResponsePolicy\";\nimport { defaultRetryPolicy } from \"./policies/defaultRetryPolicy\";\nimport { formDataPolicy } from \"./policies/formDataPolicy\";\nimport { isNode } from \"@azure/core-util\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { setClientRequestIdPolicy } from \"./policies/setClientRequestIdPolicy\";\nimport { tlsPolicy } from \"./policies/tlsPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n\n/**\n * Defines options that are used to configure the HTTP pipeline for\n * an SDK client.\n */\nexport interface PipelineOptions {\n  /**\n   * Options that control how to retry failed requests.\n   */\n  retryOptions?: PipelineRetryOptions;\n\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxySettings;\n\n  /** Options for configuring TLS authentication */\n  tlsOptions?: TlsSettings;\n\n  /**\n   * Options for how redirect responses are handled.\n   */\n  redirectOptions?: RedirectPolicyOptions;\n\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentPolicyOptions;\n\n  /**\n   * Options for setting common telemetry and tracing info to outgoing requests.\n   */\n  telemetryOptions?: TelemetryOptions;\n}\n\n/**\n * Defines options that are used to configure common telemetry and tracing info\n */\nexport interface TelemetryOptions {\n  /**\n   * The name of the header to pass the request ID to.\n   */\n  clientRequestIdHeaderName?: string;\n}\n\n/**\n * Defines options that are used to configure internal options of\n * the HTTP pipeline for an SDK client.\n */\nexport interface InternalPipelineOptions extends PipelineOptions {\n  /**\n   * Options to configure request/response logging.\n   */\n  loggingOptions?: LogPolicyOptions;\n}\n\n/**\n * Create a new pipeline with a default set of customizable policies.\n * @param options - Options to configure a custom pipeline.\n */\nexport function createPipelineFromOptions(options: InternalPipelineOptions): Pipeline {\n  const pipeline = createEmptyPipeline();\n\n  if (isNode) {\n    if (options.tlsOptions) {\n      pipeline.addPolicy(tlsPolicy(options.tlsOptions));\n    }\n    pipeline.addPolicy(proxyPolicy(options.proxyOptions));\n    pipeline.addPolicy(decompressResponsePolicy());\n  }\n\n  pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });\n  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));\n  pipeline.addPolicy(setClientRequestIdPolicy(options.telemetryOptions?.clientRequestIdHeaderName));\n  // The multipart policy is added after policies with no phase, so that\n  // policies can be added between it and formDataPolicy to modify\n  // properties (e.g., making the boundary constant in recorded tests).\n  pipeline.addPolicy(multipartPolicy(), { afterPhase: \"Deserialize\" });\n  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n  pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: \"Retry\" });\n  if (isNode) {\n    // Both XHR and Fetch expect to handle redirects automatically,\n    // so only include this policy when we're in Node.\n    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: \"Retry\" });\n  }\n  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: \"Sign\" });\n\n  return pipeline;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as http from \"http\";\nimport * as https from \"https\";\nimport * as zlib from \"zlib\";\nimport { Transform } from \"stream\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport type {\n  HttpClient,\n  HttpHeaders,\n  PipelineRequest,\n  PipelineResponse,\n  RequestBodyType,\n  TlsSettings,\n  TransferProgressEvent,\n} from \"./interfaces\";\nimport { createHttpHeaders } from \"./httpHeaders\";\nimport { RestError } from \"./restError\";\nimport type { IncomingMessage } from \"http\";\nimport { logger } from \"./log\";\n\nconst DEFAULT_TLS_SETTINGS = {};\n\nfunction isReadableStream(body: any): body is NodeJS.ReadableStream {\n  return body && typeof body.pipe === \"function\";\n}\n\nfunction isStreamComplete(stream: NodeJS.ReadableStream): Promise<void> {\n  return new Promise((resolve) => {\n    stream.on(\"close\", resolve);\n    stream.on(\"end\", resolve);\n    stream.on(\"error\", resolve);\n  });\n}\n\nfunction isArrayBuffer(body: any): body is ArrayBuffer | ArrayBufferView {\n  return body && typeof body.byteLength === \"number\";\n}\n\nclass ReportTransform extends Transform {\n  private loadedBytes = 0;\n  private progressCallback: (progress: TransferProgressEvent) => void;\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  _transform(chunk: string | Buffer, _encoding: string, callback: Function): void {\n    this.push(chunk);\n    this.loadedBytes += chunk.length;\n    try {\n      this.progressCallback({ loadedBytes: this.loadedBytes });\n      callback();\n    } catch (e: any) {\n      callback(e);\n    }\n  }\n\n  constructor(progressCallback: (progress: TransferProgressEvent) => void) {\n    super();\n    this.progressCallback = progressCallback;\n  }\n}\n\n/**\n * A HttpClient implementation that uses Node's \"https\" module to send HTTPS requests.\n * @internal\n */\nclass NodeHttpClient implements HttpClient {\n  private cachedHttpAgent?: http.Agent;\n  private cachedHttpsAgents: WeakMap<TlsSettings, https.Agent> = new WeakMap();\n\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const abortController = new AbortController();\n    let abortListener: ((event: any) => void) | undefined;\n    if (request.abortSignal) {\n      if (request.abortSignal.aborted) {\n        throw new AbortError(\"The operation was aborted.\");\n      }\n\n      abortListener = (event: Event) => {\n        if (event.type === \"abort\") {\n          abortController.abort();\n        }\n      };\n      request.abortSignal.addEventListener(\"abort\", abortListener);\n    }\n\n    if (request.timeout > 0) {\n      setTimeout(() => {\n        abortController.abort();\n      }, request.timeout);\n    }\n\n    const acceptEncoding = request.headers.get(\"Accept-Encoding\");\n    const shouldDecompress =\n      acceptEncoding?.includes(\"gzip\") || acceptEncoding?.includes(\"deflate\");\n\n    let body = typeof request.body === \"function\" ? request.body() : request.body;\n    if (body && !request.headers.has(\"Content-Length\")) {\n      const bodyLength = getBodyLength(body);\n      if (bodyLength !== null) {\n        request.headers.set(\"Content-Length\", bodyLength);\n      }\n    }\n\n    let responseStream: NodeJS.ReadableStream | undefined;\n    try {\n      if (body && request.onUploadProgress) {\n        const onUploadProgress = request.onUploadProgress;\n        const uploadReportStream = new ReportTransform(onUploadProgress);\n        uploadReportStream.on(\"error\", (e) => {\n          logger.error(\"Error in upload progress\", e);\n        });\n        if (isReadableStream(body)) {\n          body.pipe(uploadReportStream);\n        } else {\n          uploadReportStream.end(body);\n        }\n\n        body = uploadReportStream;\n      }\n\n      const res = await this.makeRequest(request, abortController, body);\n\n      const headers = getResponseHeaders(res);\n\n      const status = res.statusCode ?? 0;\n      const response: PipelineResponse = {\n        status,\n        headers,\n        request,\n      };\n\n      // Responses to HEAD must not have a body.\n      // If they do return a body, that body must be ignored.\n      if (request.method === \"HEAD\") {\n        // call resume() and not destroy() to avoid closing the socket\n        // and losing keep alive\n        res.resume();\n        return response;\n      }\n\n      responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;\n\n      const onDownloadProgress = request.onDownloadProgress;\n      if (onDownloadProgress) {\n        const downloadReportStream = new ReportTransform(onDownloadProgress);\n        downloadReportStream.on(\"error\", (e) => {\n          logger.error(\"Error in download progress\", e);\n        });\n        responseStream.pipe(downloadReportStream);\n        responseStream = downloadReportStream;\n      }\n\n      if (\n        // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n        request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||\n        request.streamResponseStatusCodes?.has(response.status)\n      ) {\n        response.readableStreamBody = responseStream;\n      } else {\n        response.bodyAsText = await streamToText(responseStream);\n      }\n\n      return response;\n    } finally {\n      // clean up event listener\n      if (request.abortSignal && abortListener) {\n        let uploadStreamDone = Promise.resolve();\n        if (isReadableStream(body)) {\n          uploadStreamDone = isStreamComplete(body);\n        }\n        let downloadStreamDone = Promise.resolve();\n        if (isReadableStream(responseStream)) {\n          downloadStreamDone = isStreamComplete(responseStream);\n        }\n\n        Promise.all([uploadStreamDone, downloadStreamDone])\n          .then(() => {\n            // eslint-disable-next-line promise/always-return\n            if (abortListener) {\n              request.abortSignal?.removeEventListener(\"abort\", abortListener);\n            }\n          })\n          .catch((e) => {\n            logger.warning(\"Error when cleaning up abortListener on httpRequest\", e);\n          });\n      }\n    }\n  }\n\n  private makeRequest(\n    request: PipelineRequest,\n    abortController: AbortController,\n    body?: RequestBodyType,\n  ): Promise<http.IncomingMessage> {\n    const url = new URL(request.url);\n\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    const agent = (request.agent as http.Agent) ?? this.getOrCreateAgent(request, isInsecure);\n    const options: http.RequestOptions = {\n      agent,\n      hostname: url.hostname,\n      path: `${url.pathname}${url.search}`,\n      port: url.port,\n      method: request.method,\n      headers: request.headers.toJSON({ preserveCase: true }),\n    };\n\n    return new Promise<http.IncomingMessage>((resolve, reject) => {\n      const req = isInsecure ? http.request(options, resolve) : https.request(options, resolve);\n\n      req.once(\"error\", (err: Error & { code?: string }) => {\n        reject(\n          new RestError(err.message, { code: err.code ?? RestError.REQUEST_SEND_ERROR, request }),\n        );\n      });\n\n      abortController.signal.addEventListener(\"abort\", () => {\n        const abortError = new AbortError(\"The operation was aborted.\");\n        req.destroy(abortError);\n        reject(abortError);\n      });\n      if (body && isReadableStream(body)) {\n        body.pipe(req);\n      } else if (body) {\n        if (typeof body === \"string\" || Buffer.isBuffer(body)) {\n          req.end(body);\n        } else if (isArrayBuffer(body)) {\n          req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));\n        } else {\n          logger.error(\"Unrecognized body type\", body);\n          reject(new RestError(\"Unrecognized body type\"));\n        }\n      } else {\n        // streams don't like \"undefined\" being passed as data\n        req.end();\n      }\n    });\n  }\n\n  private getOrCreateAgent(request: PipelineRequest, isInsecure: boolean): http.Agent {\n    const disableKeepAlive = request.disableKeepAlive;\n\n    // Handle Insecure requests first\n    if (isInsecure) {\n      if (disableKeepAlive) {\n        // keepAlive:false is the default so we don't need a custom Agent\n        return http.globalAgent;\n      }\n\n      if (!this.cachedHttpAgent) {\n        // If there is no cached agent create a new one and cache it.\n        this.cachedHttpAgent = new http.Agent({ keepAlive: true });\n      }\n      return this.cachedHttpAgent;\n    } else {\n      if (disableKeepAlive && !request.tlsSettings) {\n        // When there are no tlsSettings and keepAlive is false\n        // we don't need a custom agent\n        return https.globalAgent;\n      }\n\n      // We use the tlsSettings to index cached clients\n      const tlsSettings = request.tlsSettings ?? DEFAULT_TLS_SETTINGS;\n\n      // Get the cached agent or create a new one with the\n      // provided values for keepAlive and tlsSettings\n      let agent = this.cachedHttpsAgents.get(tlsSettings);\n\n      if (agent && agent.options.keepAlive === !disableKeepAlive) {\n        return agent;\n      }\n\n      logger.info(\"No cached TLS Agent exist, creating a new Agent\");\n      agent = new https.Agent({\n        // keepAlive is true if disableKeepAlive is false.\n        keepAlive: !disableKeepAlive,\n        // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.\n        ...tlsSettings,\n      });\n\n      this.cachedHttpsAgents.set(tlsSettings, agent);\n      return agent;\n    }\n  }\n}\n\nfunction getResponseHeaders(res: IncomingMessage): HttpHeaders {\n  const headers = createHttpHeaders();\n  for (const header of Object.keys(res.headers)) {\n    const value = res.headers[header];\n    if (Array.isArray(value)) {\n      if (value.length > 0) {\n        headers.set(header, value[0]);\n      }\n    } else if (value) {\n      headers.set(header, value);\n    }\n  }\n  return headers;\n}\n\nfunction getDecodedResponseStream(\n  stream: IncomingMessage,\n  headers: HttpHeaders,\n): NodeJS.ReadableStream {\n  const contentEncoding = headers.get(\"Content-Encoding\");\n  if (contentEncoding === \"gzip\") {\n    const unzip = zlib.createGunzip();\n    stream.pipe(unzip);\n    return unzip;\n  } else if (contentEncoding === \"deflate\") {\n    const inflate = zlib.createInflate();\n    stream.pipe(inflate);\n    return inflate;\n  }\n\n  return stream;\n}\n\nfunction streamToText(stream: NodeJS.ReadableStream): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    const buffer: Buffer[] = [];\n\n    stream.on(\"data\", (chunk) => {\n      if (Buffer.isBuffer(chunk)) {\n        buffer.push(chunk);\n      } else {\n        buffer.push(Buffer.from(chunk));\n      }\n    });\n    stream.on(\"end\", () => {\n      resolve(Buffer.concat(buffer).toString(\"utf8\"));\n    });\n    stream.on(\"error\", (e) => {\n      if (e && e?.name === \"AbortError\") {\n        reject(e);\n      } else {\n        reject(\n          new RestError(`Error reading response as text: ${e.message}`, {\n            code: RestError.PARSE_ERROR,\n          }),\n        );\n      }\n    });\n  });\n}\n\n/** @internal */\nexport function getBodyLength(body: RequestBodyType): number | null {\n  if (!body) {\n    return 0;\n  } else if (Buffer.isBuffer(body)) {\n    return body.length;\n  } else if (isReadableStream(body)) {\n    return null;\n  } else if (isArrayBuffer(body)) {\n    return body.byteLength;\n  } else if (typeof body === \"string\") {\n    return Buffer.from(body).length;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Create a new HttpClient instance for the NodeJS environment.\n * @internal\n */\nexport function createNodeHttpClient(): HttpClient {\n  return new NodeHttpClient();\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { HttpClient } from \"./interfaces\";\nimport { createNodeHttpClient } from \"./nodeHttpClient\";\n\n/**\n * Create the correct HttpClient for the current environment.\n */\nexport function createDefaultHttpClient(): HttpClient {\n  return createNodeHttpClient();\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type {\n  FormDataMap,\n  HttpHeaders,\n  HttpMethods,\n  MultipartRequestBody,\n  PipelineRequest,\n  ProxySettings,\n  RequestBodyType,\n  TransferProgressEvent,\n} from \"./interfaces\";\nimport { createHttpHeaders } from \"./httpHeaders\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { randomUUID } from \"@azure/core-util\";\nimport type { OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * Settings to initialize a request.\n * Almost equivalent to Partial<PipelineRequest>, but url is mandatory.\n */\nexport interface PipelineRequestOptions {\n  /**\n   * The URL to make the request to.\n   */\n  url: string;\n\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method?: HttpMethods;\n\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers?: HttpHeaders;\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   * Defaults to 0, which disables the timeout.\n   */\n  timeout?: number;\n\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   * Defaults to false.\n   */\n  withCredentials?: boolean;\n\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId?: string;\n\n  /**\n   * The HTTP body content (if any)\n   */\n  body?: RequestBodyType;\n\n  /**\n   * Body for a multipart request.\n   */\n  multipartBody?: MultipartRequestBody;\n\n  /**\n   * To simulate a browser form post\n   */\n  formData?: FormDataMap;\n\n  /**\n   * A list of response status codes whose corresponding PipelineResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n\n  /**\n   * BROWSER ONLY\n   *\n   * A browser only option to enable use of the Streams API. If this option is set and streaming is used\n   * (see `streamResponseStatusCodes`), the response will have a property `browserStream` instead of\n   * `blobBody` which will be undefined.\n   *\n   * Default value is false\n   */\n  enableBrowserStreams?: boolean;\n\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n\n  /**\n   * If the connection should not be reused.\n   */\n  disableKeepAlive?: boolean;\n\n  /**\n   * Used to abort the request later.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  tracingOptions?: OperationTracingOptions;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Set to true if the request is sent over HTTP instead of HTTPS */\n  allowInsecureConnection?: boolean;\n}\n\nclass PipelineRequestImpl implements PipelineRequest {\n  public url: string;\n  public method: HttpMethods;\n  public headers: HttpHeaders;\n  public timeout: number;\n  public withCredentials: boolean;\n  public body?: RequestBodyType;\n  public multipartBody?: MultipartRequestBody;\n  public formData?: FormDataMap;\n  public streamResponseStatusCodes?: Set<number>;\n  public enableBrowserStreams: boolean;\n\n  public proxySettings?: ProxySettings;\n  public disableKeepAlive: boolean;\n  public abortSignal?: AbortSignalLike;\n  public requestId: string;\n  public tracingOptions?: OperationTracingOptions;\n  public allowInsecureConnection?: boolean;\n  public onUploadProgress?: (progress: TransferProgressEvent) => void;\n  public onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  constructor(options: PipelineRequestOptions) {\n    this.url = options.url;\n    this.body = options.body;\n    this.headers = options.headers ?? createHttpHeaders();\n    this.method = options.method ?? \"GET\";\n    this.timeout = options.timeout ?? 0;\n    this.multipartBody = options.multipartBody;\n    this.formData = options.formData;\n    this.disableKeepAlive = options.disableKeepAlive ?? false;\n    this.proxySettings = options.proxySettings;\n    this.streamResponseStatusCodes = options.streamResponseStatusCodes;\n    this.withCredentials = options.withCredentials ?? false;\n    this.abortSignal = options.abortSignal;\n    this.tracingOptions = options.tracingOptions;\n    this.onUploadProgress = options.onUploadProgress;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.requestId = options.requestId || randomUUID();\n    this.allowInsecureConnection = options.allowInsecureConnection ?? false;\n    this.enableBrowserStreams = options.enableBrowserStreams ?? false;\n  }\n}\n\n/**\n * Creates a new pipeline request with the given options.\n * This method is to allow for the easy setting of default values and not required.\n * @param options - The options to create the request with.\n */\nexport function createPipelineRequest(options: PipelineRequestOptions): PipelineRequest {\n  return new PipelineRequestImpl(options);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy\";\nimport { retryPolicy } from \"./retryPolicy\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\n/**\n * The programmatic identifier of the exponentialRetryPolicy.\n */\nexport const exponentialRetryPolicyName = \"exponentialRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface ExponentialRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts. Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n   * (1 second.) The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 64000 (64 seconds).\n   */\n  maxRetryDelayInMs?: number;\n}\n\n/**\n * A policy that attempts to retry requests while introducing an exponentially increasing delay.\n * @param options - Options that configure retry logic.\n */\nexport function exponentialRetryPolicy(\n  options: ExponentialRetryPolicyOptions = {},\n): PipelinePolicy {\n  return retryPolicy(\n    [\n      exponentialRetryStrategy({\n        ...options,\n        ignoreSystemErrors: true,\n      }),\n    ],\n    {\n      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n    },\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy\";\nimport { retryPolicy } from \"./retryPolicy\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\n/**\n * Name of the {@link systemErrorRetryPolicy}\n */\nexport const systemErrorRetryPolicyName = \"systemErrorRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface SystemErrorRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts. Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n   * (1 second.) The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 64000 (64 seconds).\n   */\n  maxRetryDelayInMs?: number;\n}\n\n/**\n * A retry policy that specifically seeks to handle errors in the\n * underlying transport layer (e.g. DNS lookup failures) rather than\n * retryable error codes from the server itself.\n * @param options - Options that customize the policy.\n */\nexport function systemErrorRetryPolicy(\n  options: SystemErrorRetryPolicyOptions = {},\n): PipelinePolicy {\n  return {\n    name: systemErrorRetryPolicyName,\n    sendRequest: retryPolicy(\n      [\n        exponentialRetryStrategy({\n          ...options,\n          ignoreHttpStatusCodes: true,\n        }),\n      ],\n      {\n        maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n      },\n    ).sendRequest,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { throttlingRetryStrategy } from \"../retryStrategies/throttlingRetryStrategy\";\nimport { retryPolicy } from \"./retryPolicy\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\n/**\n * Name of the {@link throttlingRetryPolicy}\n */\nexport const throttlingRetryPolicyName = \"throttlingRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface ThrottlingRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts. Defaults to 3.\n   */\n  maxRetries?: number;\n}\n\n/**\n * A policy that retries when the server sends a 429 response with a Retry-After header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n *\n * @param options - Options that configure retry logic.\n */\nexport function throttlingRetryPolicy(options: ThrottlingRetryPolicyOptions = {}): PipelinePolicy {\n  return {\n    name: throttlingRetryPolicyName,\n    sendRequest: retryPolicy([throttlingRetryStrategy()], {\n      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n    }).sendRequest,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { delay } from \"./helpers\";\n\n/**\n * A function that gets a promise of an access token and allows providing\n * options.\n *\n * @param options - the options to pass to the underlying token provider\n */\nexport type AccessTokenGetter = (\n  scopes: string | string[],\n  options: GetTokenOptions,\n) => Promise<AccessToken>;\n\nexport interface TokenCyclerOptions {\n  /**\n   * The window of time before token expiration during which the token will be\n   * considered unusable due to risk of the token expiring before sending the\n   * request.\n   *\n   * This will only become meaningful if the refresh fails for over\n   * (refreshWindow - forcedRefreshWindow) milliseconds.\n   */\n  forcedRefreshWindowInMs: number;\n  /**\n   * Interval in milliseconds to retry failed token refreshes.\n   */\n  retryIntervalInMs: number;\n  /**\n   * The window of time before token expiration during which\n   * we will attempt to refresh the token.\n   */\n  refreshWindowInMs: number;\n}\n\n// Default options for the cycler if none are provided\nexport const DEFAULT_CYCLER_OPTIONS: TokenCyclerOptions = {\n  forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires\n  retryIntervalInMs: 3000, // Allow refresh attempts every 3s\n  refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry\n};\n\n/**\n * Converts an an unreliable access token getter (which may resolve with null)\n * into an AccessTokenGetter by retrying the unreliable getter in a regular\n * interval.\n *\n * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.\n * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.\n * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.\n * @returns - A promise that, if it resolves, will resolve with an access token.\n */\nasync function beginRefresh(\n  getAccessToken: () => Promise<AccessToken | null>,\n  retryIntervalInMs: number,\n  refreshTimeout: number,\n): Promise<AccessToken> {\n  // This wrapper handles exceptions gracefully as long as we haven't exceeded\n  // the timeout.\n  async function tryGetAccessToken(): Promise<AccessToken | null> {\n    if (Date.now() < refreshTimeout) {\n      try {\n        return await getAccessToken();\n      } catch {\n        return null;\n      }\n    } else {\n      const finalToken = await getAccessToken();\n\n      // Timeout is up, so throw if it's still null\n      if (finalToken === null) {\n        throw new Error(\"Failed to refresh access token.\");\n      }\n\n      return finalToken;\n    }\n  }\n\n  let token: AccessToken | null = await tryGetAccessToken();\n\n  while (token === null) {\n    await delay(retryIntervalInMs);\n\n    token = await tryGetAccessToken();\n  }\n\n  return token;\n}\n\n/**\n * Creates a token cycler from a credential, scopes, and optional settings.\n *\n * A token cycler represents a way to reliably retrieve a valid access token\n * from a TokenCredential. It will handle initializing the token, refreshing it\n * when it nears expiration, and synchronizes refresh attempts to avoid\n * concurrency hazards.\n *\n * @param credential - the underlying TokenCredential that provides the access\n * token\n * @param tokenCyclerOptions - optionally override default settings for the cycler\n *\n * @returns - a function that reliably produces a valid access token\n */\nexport function createTokenCycler(\n  credential: TokenCredential,\n  tokenCyclerOptions?: Partial<TokenCyclerOptions>,\n): AccessTokenGetter {\n  let refreshWorker: Promise<AccessToken> | null = null;\n  let token: AccessToken | null = null;\n  let tenantId: string | undefined;\n\n  const options = {\n    ...DEFAULT_CYCLER_OPTIONS,\n    ...tokenCyclerOptions,\n  };\n\n  /**\n   * This little holder defines several predicates that we use to construct\n   * the rules of refreshing the token.\n   */\n  const cycler = {\n    /**\n     * Produces true if a refresh job is currently in progress.\n     */\n    get isRefreshing(): boolean {\n      return refreshWorker !== null;\n    },\n    /**\n     * Produces true if the cycler SHOULD refresh (we are within the refresh\n     * window and not already refreshing)\n     */\n    get shouldRefresh(): boolean {\n      return (\n        !cycler.isRefreshing &&\n        (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now()\n      );\n    },\n    /**\n     * Produces true if the cycler MUST refresh (null or nearly-expired\n     * token).\n     */\n    get mustRefresh(): boolean {\n      return (\n        token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now()\n      );\n    },\n  };\n\n  /**\n   * Starts a refresh job or returns the existing job if one is already\n   * running.\n   */\n  function refresh(\n    scopes: string | string[],\n    getTokenOptions: GetTokenOptions,\n  ): Promise<AccessToken> {\n    if (!cycler.isRefreshing) {\n      // We bind `scopes` here to avoid passing it around a lot\n      const tryGetAccessToken = (): Promise<AccessToken | null> =>\n        credential.getToken(scopes, getTokenOptions);\n\n      // Take advantage of promise chaining to insert an assignment to `token`\n      // before the refresh can be considered done.\n      refreshWorker = beginRefresh(\n        tryGetAccessToken,\n        options.retryIntervalInMs,\n        // If we don't have a token, then we should timeout immediately\n        token?.expiresOnTimestamp ?? Date.now(),\n      )\n        .then((_token) => {\n          refreshWorker = null;\n          token = _token;\n          tenantId = getTokenOptions.tenantId;\n          return token;\n        })\n        .catch((reason) => {\n          // We also should reset the refresher if we enter a failed state.  All\n          // existing awaiters will throw, but subsequent requests will start a\n          // new retry chain.\n          refreshWorker = null;\n          token = null;\n          tenantId = undefined;\n          throw reason;\n        });\n    }\n\n    return refreshWorker as Promise<AccessToken>;\n  }\n\n  return async (scopes: string | string[], tokenOptions: GetTokenOptions): Promise<AccessToken> => {\n    //\n    // Simple rules:\n    // - If we MUST refresh, then return the refresh task, blocking\n    //   the pipeline until a token is available.\n    // - If we SHOULD refresh, then run refresh but don't return it\n    //   (we can still use the cached token).\n    // - Return the token, since it's fine if we didn't return in\n    //   step 1.\n    //\n\n    // If the tenantId passed in token options is different to the one we have\n    // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to\n    // refresh the token with the new tenantId or token.\n    const mustRefresh =\n      tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;\n\n    if (mustRefresh) return refresh(scopes, tokenOptions);\n\n    if (cycler.shouldRefresh) {\n      refresh(scopes, tokenOptions);\n    }\n\n    return token as AccessToken;\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options sent to the authorizeRequest callback\n */\nexport interface AuthorizeRequestOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options sent to the authorizeRequestOnChallenge callback\n */\nexport interface AuthorizeRequestOnChallengeOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * Response containing the challenge.\n   */\n  response: PipelineResponse;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options to override the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n */\nexport interface ChallengeCallbacks {\n  /**\n   * Allows for the authorization of the main request of this policy before it's sent.\n   */\n  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;\n  /**\n   * Allows to handle authentication challenges and to re-authorize the request.\n   * The response containing the challenge is `options.response`.\n   * If this method returns true, the underlying request will be sent once again.\n   * The request may be modified before being sent.\n   */\n  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;\n}\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential?: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n  /**\n   * Allows for the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.\n   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.\n   */\n  challengeCallbacks?: ChallengeCallbacks;\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n  };\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions,\n): PipelinePolicy {\n  const { credential, scopes, challengeCallbacks } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest: challengeCallbacks?.authorizeRequest ?? defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge,\n    // keep all other properties\n    ...challengeCallbacks,\n  };\n\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential\n    ? createTokenCycler(credential /* , options */)\n    : () => Promise.resolve(null);\n\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\",\n        );\n      }\n\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger,\n      });\n\n      let response: PipelineResponse;\n      let error: Error | undefined;\n      try {\n        response = await next(request);\n      } catch (err: any) {\n        error = err;\n        response = err.response;\n      }\n\n      if (\n        callbacks.authorizeRequestOnChallenge &&\n        response?.status === 401 &&\n        getChallenge(response)\n      ) {\n        // processes challenge\n        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          response,\n          getAccessToken,\n          logger,\n        });\n\n        if (shouldSendRequest) {\n          return next(request);\n        }\n      }\n\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the ndJsonPolicy.\n */\nexport const ndJsonPolicyName = \"ndJsonPolicy\";\n\n/**\n * ndJsonPolicy is a policy used to control keep alive settings for every request.\n */\nexport function ndJsonPolicy(): PipelinePolicy {\n  return {\n    name: ndJsonPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      // There currently isn't a good way to bypass the serializer\n      if (typeof request.body === \"string\" && request.body.startsWith(\"[\")) {\n        const body = JSON.parse(request.body);\n        if (Array.isArray(body)) {\n          request.body = body.map((item) => JSON.stringify(item) + \"\\n\").join(\"\");\n        }\n      }\n      return next(request);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { type AccessTokenGetter, createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\nimport type { AuthorizeRequestOptions } from \"./bearerTokenAuthenticationPolicy\";\n\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\n\n/**\n * Options to configure the auxiliaryAuthenticationHeaderPolicy\n */\nexport interface AuxiliaryAuthenticationHeaderPolicyOptions {\n  /**\n   * TokenCredential list used to get token from auxiliary tenants and\n   * one credential for each tenant the client may need to access\n   */\n  credentials?: TokenCredential[];\n  /**\n   * Scopes depend on the cloud your application runs in\n   */\n  scopes: string | string[];\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n\nasync function sendAuthorizeRequest(options: AuthorizeRequestOptions): Promise<string> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n  };\n\n  return (await getAccessToken(scopes, getTokenOptions))?.token ?? \"\";\n}\n\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(\n  options: AuxiliaryAuthenticationHeaderPolicyOptions,\n): PipelinePolicy {\n  const { credentials, scopes } = options;\n  const logger = options.logger || coreLogger;\n  const tokenCyclerMap = new WeakMap<TokenCredential, AccessTokenGetter>();\n\n  return {\n    name: auxiliaryAuthenticationHeaderPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\",\n        );\n      }\n      if (!credentials || credentials.length === 0) {\n        logger.info(\n          `${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`,\n        );\n        return next(request);\n      }\n\n      const tokenPromises: Promise<string>[] = [];\n      for (const credential of credentials) {\n        let getAccessToken = tokenCyclerMap.get(credential);\n        if (!getAccessToken) {\n          getAccessToken = createTokenCycler(credential);\n          tokenCyclerMap.set(credential, getAccessToken);\n        }\n        tokenPromises.push(\n          sendAuthorizeRequest({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            getAccessToken,\n            logger,\n          }),\n        );\n      }\n      const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));\n      if (auxiliaryTokens.length === 0) {\n        logger.warning(\n          `None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`,\n        );\n        return next(request);\n      }\n      request.headers.set(\n        AUTHORIZATION_AUXILIARY_HEADER,\n        auxiliaryTokens.map((token) => `Bearer ${token}`).join(\", \"),\n      );\n\n      return next(request);\n    },\n  };\n}\n"],"names":["createClientLogger","isObject","logger","coreLogger","os","isNode","__await","stream","Readable","__asyncValues","randomUUID","stringToUint8Array","AbortError","getRandomIntegerInclusive","HttpProxyAgent","HttpsProxyAgent","inspect","isError","createTracingClient","getErrorMessage","Transform","abortController","http","https","zlib"],"mappings":"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"}