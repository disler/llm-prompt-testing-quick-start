"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readAssertions = exports.runCompareAssertion = exports.runAssertion = exports.runAssertions = exports.MODEL_GRADED_ASSERTION_TYPES = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const rouge_1 = __importDefault(require("rouge"));
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const fastest_levenshtein_1 = require("fastest-levenshtein");
const telemetry_1 = __importDefault(require("./telemetry"));
const logger_1 = __importDefault(require("./logger"));
const fetch_1 = require("./fetch");
const util_1 = require("./util");
const matchers_1 = require("./matchers");
const openaiUtil_1 = require("./providers/openaiUtil");
exports.MODEL_GRADED_ASSERTION_TYPES = new Set([
    'answer-relevance',
    'context-faithfulness',
    'context-recall',
    'context-relevance',
    'llm-rubric',
    'model-graded-closedqa',
    'factuality',
    'model-graded-factuality',
]);
const ajv = new ajv_1.default();
(0, ajv_formats_1.default)(ajv);
const nunjucks = (0, util_1.getNunjucksEngine)();
function coerceString(value) {
    if (typeof value === 'string') {
        return value;
    }
    return JSON.stringify(value);
}
function handleRougeScore(baseType, assertion, expected, output, inverted) {
    const fnName = baseType[baseType.length - 1];
    const rougeMethod = rouge_1.default[fnName];
    const score = rougeMethod(output, expected);
    const pass = score >= (assertion.threshold || 0.75) != inverted;
    return {
        pass,
        score: inverted ? 1 - score : score,
        reason: pass
            ? `${baseType.toUpperCase()} score ${score} is greater than or equal to threshold ${assertion.threshold || 0.75}`
            : `${baseType.toUpperCase()} score ${score} is less than threshold ${assertion.threshold || 0.75}`,
        assertion,
    };
}
async function runAssertions({ prompt, provider, test, output, latencyMs, logProbs, cost, }) {
    const tokensUsed = {
        total: 0,
        prompt: 0,
        completion: 0,
    };
    if (!test.assert || test.assert.length < 1) {
        return { pass: true, score: 1, reason: 'No assertions', tokensUsed, assertion: null };
    }
    let totalScore = 0;
    let totalWeight = 0;
    let allPass = true;
    let failedReason = '';
    const componentResults = [];
    const namedScores = {};
    for (const assertion of test.assert) {
        if (assertion.type.startsWith('select-')) {
            // Select-type assertions are handled separately because they depend on multiple outputs.
            continue;
        }
        const weight = assertion.weight || 1;
        totalWeight += weight;
        const result = await runAssertion({
            prompt,
            provider,
            assertion,
            test,
            output,
            latencyMs,
            logProbs,
            cost,
        });
        totalScore += result.score * weight;
        componentResults.push(result);
        if (assertion.metric) {
            namedScores[assertion.metric] = (namedScores[assertion.metric] || 0) + result.score;
        }
        if (result.tokensUsed) {
            tokensUsed.total += result.tokensUsed.total;
            tokensUsed.prompt += result.tokensUsed.prompt;
            tokensUsed.completion += result.tokensUsed.completion;
        }
        if (!result.pass) {
            allPass = false;
            failedReason = result.reason;
            if (process.env.PROMPTFOO_SHORT_CIRCUIT_TEST_FAILURES) {
                return result;
            }
        }
    }
    const finalScore = totalScore / totalWeight;
    let finalReason = allPass ? 'All assertions passed' : failedReason;
    if (test.threshold) {
        // Existence of a test threshold overrides the pass/fail status of individual assertions
        allPass = finalScore >= test.threshold;
        if (allPass) {
            finalReason = `Aggregate score ${finalScore.toFixed(2)} â‰¥ ${test.threshold} threshold`;
        }
        else {
            finalReason = `Aggregate score ${finalScore.toFixed(2)} < ${test.threshold} threshold`;
        }
    }
    return {
        pass: allPass,
        score: finalScore,
        namedScores: namedScores,
        reason: finalReason,
        tokensUsed,
        componentResults,
        assertion: null,
    };
}
exports.runAssertions = runAssertions;
async function runAssertion({ prompt, provider, assertion, test, output, latencyMs, logProbs, cost, }) {
    let pass = false;
    let score = 0.0;
    (0, tiny_invariant_1.default)(assertion.type, `Assertion must have a type: ${JSON.stringify(assertion)}`);
    const inverse = assertion.type.startsWith('not-');
    const baseType = inverse ? assertion.type.slice(4) : assertion.type;
    telemetry_1.default.record('assertion_used', {
        type: baseType,
    });
    if (assertion.transform) {
        output = (0, util_1.transformOutput)(assertion.transform, output, { vars: test.vars });
    }
    const outputString = coerceString(output);
    const context = {
        prompt,
        vars: test.vars || {},
        test,
    };
    // Render assertion values
    let renderedValue = assertion.value;
    let valueFromScript;
    if (typeof renderedValue === 'string') {
        if (renderedValue.startsWith('file://')) {
            // Load the file
            const filePath = renderedValue.slice('file://'.length);
            if (filePath.endsWith('.js') || filePath.endsWith('.cjs')) {
                const requiredModule = require(path_1.default.resolve(filePath));
                if (typeof requiredModule === 'function') {
                    valueFromScript = await Promise.resolve(requiredModule(output, context));
                }
                else if (requiredModule.default && typeof requiredModule.default === 'function') {
                    valueFromScript = await Promise.resolve(requiredModule.default(output, context));
                }
                else {
                    throw new Error(`Assertion malformed: ${filePath} must export a function or have a default export as a function`);
                }
                logger_1.default.debug(`Javascript script ${filePath} output: ${valueFromScript}`);
            }
            else if (filePath.endsWith('.py')) {
                const args = [
                    filePath,
                    typeof output === 'string' ? output : JSON.stringify(output),
                    JSON.stringify(context),
                ];
                const pythonScriptOutput = await new Promise((resolve, reject) => {
                    (0, child_process_1.execFile)(process.env.PROMPTFOO_PYTHON || 'python', args, null, (error, stdout, stderr) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        const stringErr = String(stderr);
                        if (stringErr) {
                            reject(new Error(stringErr));
                        }
                        else {
                            resolve(String(stdout));
                        }
                    });
                });
                valueFromScript = pythonScriptOutput.trim();
                logger_1.default.debug(`Python script ${filePath} output: ${valueFromScript}`);
            }
            else if (filePath.endsWith('.json')) {
                valueFromScript = JSON.parse(fs_1.default.readFileSync(filePath, 'utf8'));
            }
            else if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
                valueFromScript = js_yaml_1.default.load(fs_1.default.readFileSync(filePath, 'utf8'));
            }
            else {
                throw new Error(`Assertion malformed: ${filePath} must end in .js or .py`);
            }
        }
        else {
            // It's a normal string value
            renderedValue = nunjucks.renderString(renderedValue, test.vars || {});
        }
    }
    else if (renderedValue && Array.isArray(renderedValue)) {
        // Unpack the array
        renderedValue = renderedValue.map((v) => nunjucks.renderString(String(v), test.vars || {}));
    }
    if (baseType === 'equals') {
        pass = renderedValue == outputString;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output "${renderedValue}" but got "${outputString}"`,
            assertion,
        };
    }
    if (baseType === 'is-json') {
        let parsedJson;
        try {
            parsedJson = JSON.parse(outputString);
            pass = !inverse;
        }
        catch (err) {
            pass = inverse;
        }
        if (pass && renderedValue) {
            let validate;
            if (typeof renderedValue === 'string' && renderedValue.startsWith('file://')) {
                // Reference the JSON schema from external file
                const schema = valueFromScript;
                (0, tiny_invariant_1.default)(schema, 'is-json references a file that does not export a JSON schema');
                validate = ajv.compile(schema);
            }
            else if (typeof renderedValue === 'object') {
                // Value is JSON schema
                validate = ajv.compile(renderedValue);
            }
            else {
                throw new Error('is-json assertion must have a string or object value');
            }
            pass = validate(parsedJson);
            if (!pass) {
                return {
                    pass,
                    score: 0,
                    reason: `JSON does not conform to the provided schema. Errors: ${ajv.errorsText(validate.errors)}`,
                    assertion,
                };
            }
        }
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass ? 'Assertion passed' : 'Expected output to be valid JSON',
            assertion,
        };
    }
    if (baseType === 'contains') {
        (0, tiny_invariant_1.default)(renderedValue, '"contains" assertion type must have a string or number value');
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string' || typeof renderedValue === 'number', '"contains" assertion type must have a string or number value');
        pass = outputString.includes(String(renderedValue)) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}contain "${renderedValue}"`,
            assertion,
        };
    }
    if (baseType === 'contains-any') {
        (0, tiny_invariant_1.default)(renderedValue, '"contains-any" assertion type must have a value');
        (0, tiny_invariant_1.default)(Array.isArray(renderedValue), '"contains-any" assertion type must have an array value');
        pass = renderedValue.some((value) => outputString.includes(String(value))) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}contain one of "${renderedValue.join(', ')}"`,
            assertion,
        };
    }
    if (baseType === 'icontains-any') {
        (0, tiny_invariant_1.default)(renderedValue, '"icontains-any" assertion type must have a value');
        (0, tiny_invariant_1.default)(Array.isArray(renderedValue), '"icontains-any" assertion type must have an array value');
        pass =
            renderedValue.some((value) => outputString.toLowerCase().includes(String(value).toLowerCase())) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}contain one of "${renderedValue.join(', ')}"`,
            assertion,
        };
    }
    if (baseType === 'contains-all') {
        (0, tiny_invariant_1.default)(renderedValue, '"contains-all" assertion type must have a value');
        (0, tiny_invariant_1.default)(Array.isArray(renderedValue), '"contains-all" assertion type must have an array value');
        pass = renderedValue.every((value) => outputString.includes(String(value))) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}contain all of "${renderedValue.join(', ')}"`,
            assertion,
        };
    }
    if (baseType === 'icontains-all') {
        (0, tiny_invariant_1.default)(renderedValue, '"icontains-all" assertion type must have a value');
        (0, tiny_invariant_1.default)(Array.isArray(renderedValue), '"icontains-all" assertion type must have an array value');
        pass =
            renderedValue.every((value) => outputString.toLowerCase().includes(String(value).toLowerCase())) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}contain all of "${renderedValue.join(', ')}"`,
            assertion,
        };
    }
    if (baseType === 'regex') {
        (0, tiny_invariant_1.default)(renderedValue, '"regex" assertion type must have a string value');
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', '"regex" assertion type must have a string value');
        const regex = new RegExp(renderedValue);
        pass = regex.test(outputString) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}match regex "${renderedValue}"`,
            assertion,
        };
    }
    if (baseType === 'icontains') {
        (0, tiny_invariant_1.default)(renderedValue, '"icontains" assertion type must have a string or number value');
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string' || typeof renderedValue === 'number', '"icontains" assertion type must have a string or number value');
        pass = outputString.toLowerCase().includes(String(renderedValue).toLowerCase()) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}contain "${renderedValue}"`,
            assertion,
        };
    }
    if (baseType === 'starts-with') {
        (0, tiny_invariant_1.default)(renderedValue, '"starts-with" assertion type must have a string value');
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', '"starts-with" assertion type must have a string value');
        pass = outputString.startsWith(String(renderedValue)) !== inverse;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Expected output to ${inverse ? 'not ' : ''}start with "${renderedValue}"`,
            assertion,
        };
    }
    if (baseType === 'contains-json') {
        let errorMessage = 'Expected output to contain valid JSON';
        let jsonOutputs = containsJSON(outputString);
        for (const jsonMatch of jsonOutputs) {
            pass = jsonMatch !== inverse;
            if (pass && renderedValue) {
                let validate;
                if (typeof renderedValue === 'string' && renderedValue.startsWith('file://')) {
                    // Reference the JSON schema from external file
                    const schema = valueFromScript;
                    (0, tiny_invariant_1.default)(schema, 'is-json references a file that does not export a JSON schema');
                    validate = ajv.compile(schema);
                }
                else if (typeof renderedValue === 'object') {
                    // Value is JSON schema
                    validate = ajv.compile(renderedValue);
                }
                else {
                    throw new Error('is-json assertion must have a string or object value');
                }
                pass = validate(jsonMatch);
                if (pass) {
                    break;
                }
                else {
                    errorMessage = `JSON does not conform to the provided schema. Errors: ${ajv.errorsText(validate.errors)}`;
                }
            }
        }
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass ? 'Assertion passed' : errorMessage,
            assertion,
        };
    }
    if (baseType === 'is-valid-openai-tools-call') {
        const toolsOutput = output;
        (0, tiny_invariant_1.default)(Array.isArray(toolsOutput), 'is-valid-tools assertion must evaluate an array');
        (0, tiny_invariant_1.default)(toolsOutput.length > 0, 'is-valid-tools assertion must evaluate a non-empty array');
        (0, tiny_invariant_1.default)(typeof toolsOutput[0].function.name === 'string', 'is-valid-tools assertion must evaluate an array of objects with string name properties');
        (0, tiny_invariant_1.default)(typeof toolsOutput[0].function.arguments === 'string', 'is-valid-tools assertion must evaluate an array of objects with string arguments properties');
        try {
            toolsOutput.forEach((toolOutput) => (0, openaiUtil_1.validateFunctionCall)(toolOutput.function, provider.config.tools?.map((tool) => tool.function)));
            return {
                pass: true,
                score: 1,
                reason: 'Assertion passed',
                assertion,
            };
        }
        catch (err) {
            return {
                pass: false,
                score: 0,
                reason: err.message,
                assertion,
            };
        }
    }
    if (baseType === 'is-valid-openai-function-call') {
        const functionOutput = output;
        (0, tiny_invariant_1.default)(typeof functionOutput === 'object' &&
            typeof functionOutput.name === 'string' &&
            typeof functionOutput.arguments === 'string', 'is-valid-function assertion must evaluate an object with string name and arguments properties');
        try {
            (0, openaiUtil_1.validateFunctionCall)(functionOutput, provider.config.functions);
            return {
                pass: true,
                score: 1,
                reason: 'Assertion passed',
                assertion,
            };
        }
        catch (err) {
            return {
                pass: false,
                score: 0,
                reason: err.message,
                assertion,
            };
        }
    }
    if (baseType === 'javascript') {
        try {
            if (typeof assertion.value === 'function') {
                const ret = assertion.value(outputString, test, assertion);
                if (ret && !ret.assertion) {
                    // Populate the assertion object if the custom function didn't return it.
                    const functionString = assertion.value.toString();
                    ret.assertion = {
                        type: 'javascript',
                        value: functionString.length > 50 ? functionString.slice(0, 50) + '...' : functionString,
                    };
                }
                return ret;
            }
            (0, tiny_invariant_1.default)(typeof renderedValue === 'string', 'javascript assertion must have a string value');
            let result;
            if (typeof valueFromScript !== 'undefined') {
                (0, tiny_invariant_1.default)(typeof valueFromScript === 'boolean' ||
                    typeof valueFromScript === 'number' ||
                    typeof valueFromScript === 'object', `Javascript assertion script must return a boolean, number, or object (${assertion.value})`);
                result = valueFromScript;
            }
            else {
                const functionBody = renderedValue.includes('\n')
                    ? renderedValue
                    : `return ${renderedValue}`;
                const customFunction = new Function('output', 'context', functionBody);
                result = customFunction(output, context);
            }
            if (typeof result === 'boolean') {
                pass = result !== inverse;
                score = pass ? 1 : 0;
            }
            else if (typeof result === 'number') {
                pass = assertion.threshold ? result >= assertion.threshold : result > 0;
                score = result;
            }
            else if (typeof result === 'object') {
                return result;
            }
            else {
                throw new Error('Custom function must return a boolean or number');
            }
        }
        catch (err) {
            return {
                pass: false,
                score: 0,
                reason: `Custom function threw error: ${err.message}
${renderedValue}`,
                assertion,
            };
        }
        return {
            pass,
            score,
            reason: pass
                ? 'Assertion passed'
                : `Custom function returned ${inverse ? 'true' : 'false'}
${renderedValue}`,
            assertion,
        };
    }
    if (baseType === 'python') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', 'python assertion must have a string value');
        try {
            let result;
            if (typeof valueFromScript !== 'undefined') {
                (0, tiny_invariant_1.default)(typeof valueFromScript === 'string', `Python assertion script must return a string (${assertion.value})`);
                result = valueFromScript;
            }
            else {
                const isMultiline = renderedValue.includes('\n');
                let pythonScript = `import json
import sys
data = json.load(sys.stdin)
output = data['output']
context = data['context']
value = data['value']
${isMultiline ? 'exec(value)' : 'print(json.dumps(eval(value)))'}`;
                const pythonProcessInput = JSON.stringify({ output, context, value: renderedValue });
                const child = (0, child_process_1.spawn)(process.env.PROMPTFOO_PYTHON || 'python', ['-u', '-c', pythonScript]);
                child.stdin.write(pythonProcessInput);
                child.stdin.end();
                let childStdout = '';
                let childStderr = '';
                await new Promise((resolve, reject) => {
                    // Collect output and wait for process to exit
                    child.stdout.on('data', (data) => {
                        childStdout += data;
                    });
                    // Listen for errors on the child process
                    child.on('error', (error) => {
                        reject(error);
                    });
                    child.stderr.on('data', (data) => {
                        childStderr += data;
                    });
                    // Listen for the process to close, which may happen after 'end'
                    child.on('close', (code) => {
                        if (code !== 0) {
                            reject(new Error(`Child process exited with code ${code}`));
                        }
                        else {
                            resolve();
                        }
                    });
                });
                if (childStderr) {
                    throw new Error(childStderr);
                }
                result = childStdout.trim();
            }
            if (result.toLowerCase() === 'true') {
                pass = true;
                score = 1.0;
            }
            else if (result.toLowerCase() === 'false') {
                pass = false;
                score = 0.0;
            }
            else if (result.startsWith('{')) {
                const parsed = JSON.parse(result);
                if (!parsed.hasOwnProperty('pass') || !parsed.hasOwnProperty('score')) {
                    throw new Error('Python assertion must return a boolean, number, or {pass, score, reason} object');
                }
                return parsed;
            }
            else {
                score = parseFloat(result);
                pass = assertion.threshold ? score >= assertion.threshold : score > 0;
                if (isNaN(score)) {
                    throw new Error('Python assertion must return a boolean, number, or {pass, score, reason} object');
                }
                if (typeof assertion.threshold !== 'undefined' && score < assertion.threshold) {
                    pass = false;
                }
            }
        }
        catch (err) {
            return {
                pass: false,
                score: 0,
                reason: `Python code execution failed: ${err.message}`,
                assertion,
            };
        }
        return {
            pass,
            score,
            reason: pass
                ? 'Assertion passed'
                : `Python code returned ${pass ? 'true' : 'false'}
${assertion.value}`,
            assertion,
        };
    }
    if (baseType === 'similar') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', 'Similarity assertion type must have a string value');
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        return {
            assertion,
            ...(await (0, matchers_1.matchesSimilarity)(renderedValue, outputString, assertion.threshold || 0.75, inverse, test.options)),
        };
    }
    if (baseType === 'llm-rubric') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string' || typeof renderedValue === 'undefined', '"llm-rubric" assertion type must have a string value');
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        test.options.rubricPrompt = assertion.rubricPrompt || test.options.rubricPrompt;
        if (test.options.rubricPrompt) {
            if (typeof test.options.rubricPrompt === 'object') {
                test.options.rubricPrompt = JSON.stringify(test.options.rubricPrompt);
            }
        }
        // Update the assertion value. This allows the web view to display the prompt.
        assertion.value = assertion.value || test.options.rubricPrompt;
        return {
            assertion,
            ...(await (0, matchers_1.matchesLlmRubric)(renderedValue || '', outputString, test.options, test.vars)),
        };
    }
    if (baseType === 'model-graded-factuality' || baseType === 'factuality') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', 'factuality assertion type must have a string value');
        (0, tiny_invariant_1.default)(prompt, 'factuality assertion type must have a prompt');
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        test.options.rubricPrompt = assertion.rubricPrompt || test.options.rubricPrompt;
        if (test.options.rubricPrompt) {
            // Substitute vars in prompt
            test.options.rubricPrompt = nunjucks.renderString(test.options.rubricPrompt, test.vars || {});
        }
        return {
            assertion,
            ...(await (0, matchers_1.matchesFactuality)(prompt, renderedValue, outputString, test.options, test.vars)),
        };
    }
    if (baseType === 'model-graded-closedqa') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', 'model-graded-closedqa assertion type must have a string value');
        (0, tiny_invariant_1.default)(prompt, 'model-graded-closedqa assertion type must have a prompt');
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        test.options.rubricPrompt = assertion.rubricPrompt || test.options.rubricPrompt;
        if (test.options.rubricPrompt) {
            // Substitute vars in prompt
            test.options.rubricPrompt = nunjucks.renderString(test.options.rubricPrompt, test.vars || {});
        }
        return {
            assertion,
            ...(await (0, matchers_1.matchesClosedQa)(prompt, renderedValue, outputString, test.options, test.vars)),
        };
    }
    if (baseType === 'answer-relevance') {
        (0, tiny_invariant_1.default)(typeof output === 'string', 'answer-relevance assertion type must evaluate a string output');
        (0, tiny_invariant_1.default)(prompt, 'answer-relevance assertion type must have a prompt');
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        return {
            assertion,
            ...(await (0, matchers_1.matchesAnswerRelevance)(prompt, output, assertion.threshold || 0, test.options)),
        };
    }
    if (baseType === 'context-recall') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', 'context-recall assertion type must have a string value');
        (0, tiny_invariant_1.default)(prompt, 'context-recall assertion type must have a prompt');
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        return {
            assertion,
            ...(await (0, matchers_1.matchesContextRecall)(typeof test.vars?.context === 'string' ? test.vars.context : prompt, renderedValue, assertion.threshold || 0, test.options, test.vars)),
        };
    }
    if (baseType === 'context-relevance') {
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        (0, tiny_invariant_1.default)(test.vars, 'context-relevance assertion type must have a vars object');
        (0, tiny_invariant_1.default)(typeof test.vars.query === 'string', 'context-relevance assertion type must have a question var');
        (0, tiny_invariant_1.default)(typeof test.vars.context === 'string', 'context-relevance assertion type must have a context var');
        return {
            assertion,
            ...(await (0, matchers_1.matchesContextRelevance)(test.vars.query, test.vars.context, assertion.threshold || 0, test.options)),
        };
    }
    if (baseType === 'context-faithfulness') {
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        (0, tiny_invariant_1.default)(test.vars, 'context-faithfulness assertion type must have a vars object');
        (0, tiny_invariant_1.default)(typeof test.vars.query === 'string', 'context-faithfulness assertion type must have a question var');
        (0, tiny_invariant_1.default)(typeof test.vars.context === 'string', 'context-faithfulness assertion type must have a context var');
        (0, tiny_invariant_1.default)(typeof output === 'string', 'context-faithfulness assertion type must have a string output');
        return {
            assertion,
            ...(await (0, matchers_1.matchesContextFaithfulness)(test.vars.query, output, test.vars.context, assertion.threshold || 0, test.options)),
        };
    }
    if (baseType === 'webhook') {
        (0, tiny_invariant_1.default)(renderedValue, '"webhook" assertion type must have a URL value');
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', '"webhook" assertion type must have a URL value');
        try {
            const context = {
                prompt,
                vars: test.vars || {},
            };
            const response = await (0, fetch_1.fetchWithRetries)(renderedValue, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ output, context }),
            }, process.env.WEBHOOK_TIMEOUT ? parseInt(process.env.WEBHOOK_TIMEOUT, 10) : 5000);
            if (!response.ok) {
                throw new Error(`Webhook response status: ${response.status}`);
            }
            const jsonResponse = await response.json();
            pass = jsonResponse.pass !== inverse;
            score =
                typeof jsonResponse.score === 'undefined'
                    ? pass
                        ? 1
                        : 0
                    : inverse
                        ? 1 - jsonResponse.score
                        : jsonResponse.score;
            const reason = jsonResponse.reason ||
                (pass ? 'Assertion passed' : `Webhook returned ${inverse ? 'true' : 'false'}`);
            return {
                pass,
                score,
                reason,
                assertion,
            };
        }
        catch (err) {
            return {
                pass: false,
                score: 0,
                reason: `Webhook error: ${err.message}`,
                assertion,
            };
        }
    }
    if (baseType === 'rouge-n') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string' || Array.isArray(renderedValue), '"rouge" assertion type must be a value (string or string array)');
        return handleRougeScore(baseType, assertion, renderedValue, outputString, inverse);
    }
    if (baseType === 'levenshtein') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', '"levenshtein" assertion type must have a string value');
        const levDistance = (0, fastest_levenshtein_1.distance)(outputString, renderedValue);
        pass = levDistance <= (assertion.threshold || 5);
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Levenshtein distance ${levDistance} is greater than threshold ${assertion.threshold || 5}`,
            assertion,
        };
    }
    if (baseType === 'classifier') {
        (0, tiny_invariant_1.default)(typeof renderedValue === 'string', '"classifier" assertion type must have a string value');
        // Assertion provider overrides test provider
        test.options = test.options || {};
        test.options.provider = assertion.provider || test.options.provider;
        return {
            assertion,
            ...(await (0, matchers_1.matchesClassification)(renderedValue, outputString, assertion.threshold ?? 1, test.options)),
        };
    }
    if (baseType === 'latency') {
        if (!assertion.threshold) {
            throw new Error('Latency assertion must have a threshold in milliseconds');
        }
        if (!latencyMs) {
            throw new Error('Latency assertion does not support cached results. Rerun the eval with --no-cache');
        }
        pass = latencyMs <= assertion.threshold;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Latency ${latencyMs}ms is greater than threshold ${assertion.threshold}ms`,
            assertion,
        };
    }
    if (baseType === 'perplexity') {
        if (!logProbs || logProbs.length === 0) {
            throw new Error('Perplexity assertion does not support providers that do not return logProbs');
        }
        const sumLogProbs = logProbs.reduce((acc, logProb) => acc + logProb, 0);
        const avgLogProb = sumLogProbs / logProbs.length;
        const perplexity = Math.exp(-avgLogProb);
        pass = assertion.threshold ? perplexity <= assertion.threshold : true;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Perplexity ${perplexity.toFixed(2)} is greater than threshold ${assertion.threshold}`,
            assertion,
        };
    }
    if (baseType === 'perplexity-score') {
        if (!logProbs || logProbs.length === 0) {
            throw new Error('perplexity-score assertion does not support providers that do not return logProbs');
        }
        const sumLogProbs = logProbs.reduce((acc, logProb) => acc + logProb, 0);
        const avgLogProb = sumLogProbs / logProbs.length;
        const perplexity = Math.exp(-avgLogProb);
        const perplexityNorm = 1 / (1 + perplexity);
        pass = assertion.threshold ? perplexityNorm >= assertion.threshold : true;
        return {
            pass,
            score: perplexityNorm,
            reason: pass
                ? 'Assertion passed'
                : `Perplexity score ${perplexityNorm.toFixed(2)} is less than threshold ${assertion.threshold}`,
            assertion,
        };
    }
    if (baseType === 'cost') {
        if (!assertion.threshold) {
            throw new Error('Cost assertion must have a threshold');
        }
        if (typeof cost === 'undefined') {
            throw new Error('Cost assertion does not support providers that do not return cost');
        }
        pass = cost <= assertion.threshold;
        return {
            pass,
            score: pass ? 1 : 0,
            reason: pass
                ? 'Assertion passed'
                : `Cost ${cost.toPrecision(2)} is greater than threshold ${assertion.threshold}`,
            assertion,
        };
    }
    throw new Error('Unknown assertion type: ' + assertion.type);
}
exports.runAssertion = runAssertion;
function containsJSON(str) {
    // This will extract all json objects from a string
    let jsonObjects = [];
    let openBracket = str.indexOf('{');
    let closeBracket = str.indexOf('}', openBracket);
    // Iterate over the string until we find a valid JSON-like pattern
    // Iterate over all trailing } until the contents parse as json
    while (openBracket !== -1) {
        const jsonStr = str.slice(openBracket, closeBracket + 1);
        try {
            jsonObjects.push(JSON.parse(jsonStr));
            // This is a valid JSON object, so start looking for
            // an opening bracket after the last closing bracket
            openBracket = str.indexOf('{', closeBracket + 1);
            closeBracket = str.indexOf('}', openBracket);
        }
        catch (err) {
            // Not a valid object, move on to the next closing bracket
            closeBracket = str.indexOf('}', closeBracket + 1);
            while (closeBracket === -1) {
                // No closing brackets made a valid json object, so
                // start looking with the next opening bracket
                openBracket = str.indexOf('{', openBracket + 1);
                closeBracket = str.indexOf('}', openBracket);
            }
        }
    }
    return jsonObjects;
}
async function runCompareAssertion(test, assertion, outputs) {
    (0, tiny_invariant_1.default)(typeof assertion.value === 'string', 'select-best must have a string value');
    test.options = test.options || {};
    test.options.provider = assertion.provider || test.options.provider;
    test.options.rubricPrompt = assertion.rubricPrompt || test.options.rubricPrompt;
    const comparisonResults = await (0, matchers_1.matchesSelectBest)(assertion.value, outputs, test.options, test.vars);
    return comparisonResults.map(result => ({
        ...result,
        assertion
    }));
}
exports.runCompareAssertion = runCompareAssertion;
async function readAssertions(filePath) {
    try {
        const assertions = js_yaml_1.default.load(fs_1.default.readFileSync(filePath, 'utf-8'));
        if (!Array.isArray(assertions) || assertions[0]?.type === undefined) {
            throw new Error('Assertions file must be an array of assertion objects');
        }
        return assertions;
    }
    catch (err) {
        throw new Error(`Failed to read assertions from ${filePath}:\n${err}`);
    }
}
exports.readAssertions = readAssertions;
// These exports are used by the node.js package (index.ts)
exports.default = {
    matchesSimilarity: matchers_1.matchesSimilarity,
    matchesClassification: matchers_1.matchesClassification,
    matchesLlmRubric: matchers_1.matchesLlmRubric,
    matchesFactuality: matchers_1.matchesFactuality,
    matchesClosedQa: matchers_1.matchesClosedQa,
    matchesAnswerRelevance: matchers_1.matchesAnswerRelevance,
    matchesContextRecall: matchers_1.matchesContextRecall,
    matchesContextRelevance: matchers_1.matchesContextRelevance,
    matchesContextFaithfulness: matchers_1.matchesContextFaithfulness,
    matchesComparisonBoolean: matchers_1.matchesSelectBest,
};
//# sourceMappingURL=assertions.js.map