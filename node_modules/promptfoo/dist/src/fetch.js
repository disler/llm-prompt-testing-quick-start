"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchWithRetries = exports.fetchWithTimeout = exports.fetchWithProxy = exports.fetchCsvFromGoogleSheet = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const proxy_agent_1 = require("proxy-agent");
async function fetchCsvFromGoogleSheet(url) {
    const csvUrl = url.replace(/\/edit.*$/, '/export?format=csv');
    const response = await fetchWithProxy(csvUrl);
    if (response.status !== 200) {
        throw new Error(`Failed to fetch CSV from Google Sheets URL: ${url}`);
    }
    const csvData = await response.text();
    return csvData;
}
exports.fetchCsvFromGoogleSheet = fetchCsvFromGoogleSheet;
async function fetchWithProxy(url, options = {}) {
    options.agent = new proxy_agent_1.ProxyAgent();
    return (0, node_fetch_1.default)(url, options);
}
exports.fetchWithProxy = fetchWithProxy;
function fetchWithTimeout(url, options = {}, timeout) {
    return new Promise((resolve, reject) => {
        const controller = new AbortController();
        const { signal } = controller;
        options.signal = signal;
        const timeoutId = setTimeout(() => {
            controller.abort();
            reject(new Error(`Request timed out after ${timeout} ms`));
        }, timeout);
        fetchWithProxy(url, options)
            .then((response) => {
            clearTimeout(timeoutId);
            resolve(response);
        })
            .catch((error) => {
            clearTimeout(timeoutId);
            reject(error);
        });
    });
}
exports.fetchWithTimeout = fetchWithTimeout;
async function fetchWithRetries(url, options = {}, timeout, retries = 4) {
    let lastError;
    const backoff = process.env.PROMPTFOO_REQUEST_BACKOFF_MS
        ? parseInt(process.env.PROMPTFOO_REQUEST_BACKOFF_MS, 10)
        : 5000;
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetchWithTimeout(url, options, timeout);
            if (process.env.PROMPTFOO_RETRY_5XX && response.status / 100 === 5) {
                throw new Error(`Internal Server Error: ${response.status} ${response.statusText}`);
            }
            return response;
        }
        catch (error) {
            lastError = error;
            const waitTime = Math.pow(2, i) * (backoff + 1000 * Math.random());
            await new Promise((resolve) => setTimeout(resolve, waitTime));
        }
    }
    throw new Error(`Request failed after ${retries} retries: ${lastError.message}`);
}
exports.fetchWithRetries = fetchWithRetries;
//# sourceMappingURL=fetch.js.map