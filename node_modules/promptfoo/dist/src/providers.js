"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadApiProvider = exports.loadApiProviders = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const logger_1 = __importDefault(require("./logger"));
const openai_1 = require("./providers/openai");
const anthropic_1 = require("./providers/anthropic");
const replicate_1 = require("./providers/replicate");
const localai_1 = require("./providers/localai");
const palm_1 = require("./providers/palm");
const llama_1 = require("./providers/llama");
const ollama_1 = require("./providers/ollama");
const vertex_1 = require("./providers/vertex");
const mistral_1 = require("./providers/mistral");
const webhook_1 = require("./providers/webhook");
const scriptCompletion_1 = require("./providers/scriptCompletion");
const azureopenai_1 = require("./providers/azureopenai");
const huggingface_1 = require("./providers/huggingface");
const bedrock_1 = require("./providers/bedrock");
const pythonCompletion_1 = require("./providers/pythonCompletion");
const cohere_1 = require("./providers/cohere");
async function loadApiProviders(providerPaths, options = {}) {
    const { basePath, env } = options;
    if (typeof providerPaths === 'string') {
        return [await loadApiProvider(providerPaths, { basePath, env })];
    }
    else if (typeof providerPaths === 'function') {
        return [
            {
                id: () => 'custom-function',
                callApi: providerPaths,
            },
        ];
    }
    else if (Array.isArray(providerPaths)) {
        return Promise.all(providerPaths.map((provider, idx) => {
            if (typeof provider === 'string') {
                return loadApiProvider(provider, { basePath, env });
            }
            else if (typeof provider === 'function') {
                return {
                    id: () => `custom-function-${idx}`,
                    callApi: provider,
                };
            }
            else if (provider.id) {
                // List of ProviderConfig objects
                return loadApiProvider(provider.id, {
                    options: provider,
                    basePath,
                    env,
                });
            }
            else {
                // List of { id: string, config: ProviderConfig } objects
                const id = Object.keys(provider)[0];
                const providerObject = provider[id];
                const context = { ...providerObject, id: providerObject.id || id };
                return loadApiProvider(id, { options: context, basePath, env });
            }
        }));
    }
    throw new Error('Invalid providers list');
}
exports.loadApiProviders = loadApiProviders;
async function loadApiProvider(providerPath, context = {}) {
    const { options = {}, basePath, env } = context;
    const providerOptions = {
        id: options.id,
        config: {
            ...options.config,
            basePath,
        },
        env,
    };
    if (providerPath.startsWith('file://')) {
        const filePath = providerPath.slice('file://'.length);
        const yamlContent = js_yaml_1.default.load(fs_1.default.readFileSync(filePath, 'utf8'));
        (0, tiny_invariant_1.default)(yamlContent, `Provider config ${filePath} is undefined`);
        (0, tiny_invariant_1.default)(yamlContent.id, `Provider config ${filePath} must have an id`);
        logger_1.default.info(`Loaded provider ${yamlContent.id} from ${filePath}`);
        return loadApiProvider(yamlContent.id, { ...context, options: yamlContent });
    }
    else if (providerPath === 'echo') {
        return {
            id: () => 'echo',
            callApi: async (input) => ({ output: input }),
        };
    }
    else if (providerPath?.startsWith('exec:')) {
        // Load script module
        const scriptPath = providerPath.split(':')[1];
        return new scriptCompletion_1.ScriptCompletionProvider(scriptPath, providerOptions);
    }
    else if (providerPath?.startsWith('python:')) {
        const scriptPath = providerPath.split(':')[1];
        return new pythonCompletion_1.PythonProvider(scriptPath, providerOptions);
    }
    else if (providerPath?.startsWith('openai:')) {
        // Load OpenAI module
        const splits = providerPath.split(':');
        const modelType = splits[1];
        const modelName = splits.slice(2).join(':');
        if (modelType === 'chat') {
            return new openai_1.OpenAiChatCompletionProvider(modelName || 'gpt-3.5-turbo', providerOptions);
        }
        else if (modelType === 'embedding' || modelType === 'embeddings') {
            return new openai_1.OpenAiEmbeddingProvider(modelName || 'text-embedding-ada-002', providerOptions);
        }
        else if (modelType === 'completion') {
            return new openai_1.OpenAiCompletionProvider(modelName || 'text-davinci-003', providerOptions);
        }
        else if (openai_1.OpenAiChatCompletionProvider.OPENAI_CHAT_MODEL_NAMES.includes(modelType)) {
            return new openai_1.OpenAiChatCompletionProvider(modelType, providerOptions);
        }
        else if (openai_1.OpenAiCompletionProvider.OPENAI_COMPLETION_MODEL_NAMES.includes(modelType)) {
            return new openai_1.OpenAiCompletionProvider(modelType, providerOptions);
        }
        else if (modelType === 'assistant') {
            return new openai_1.OpenAiAssistantProvider(modelName, providerOptions);
        }
        else if (modelType === 'image') {
            return new openai_1.OpenAiImageProvider(modelName, providerOptions);
        }
        else {
            throw new Error(`Unknown OpenAI model type: ${modelType}. Use one of the following providers: openai:chat:<model name>, openai:completion:<model name>, openai:embeddings:<model name>, openai:image:<model name>`);
        }
    }
    else if (providerPath?.startsWith('azureopenai:')) {
        // Load Azure OpenAI module
        const splits = providerPath.split(':');
        const modelType = splits[1];
        const deploymentName = splits[2];
        if (modelType === 'chat') {
            return new azureopenai_1.AzureOpenAiChatCompletionProvider(deploymentName, providerOptions);
        }
        else if (modelType === 'embedding' || modelType === 'embeddings') {
            return new azureopenai_1.AzureOpenAiEmbeddingProvider(deploymentName || 'text-embedding-ada-002', providerOptions);
        }
        else if (modelType === 'completion') {
            return new azureopenai_1.AzureOpenAiCompletionProvider(deploymentName, providerOptions);
        }
        else {
            throw new Error(`Unknown Azure OpenAI model type: ${modelType}. Use one of the following providers: azureopenai:chat:<model name>, azureopenai:completion:<model name>`);
        }
    }
    else if (providerPath?.startsWith('anthropic:')) {
        const splits = providerPath.split(':');
        const modelType = splits[1];
        const modelName = splits[2];
        if (modelType === 'completion') {
            return new anthropic_1.AnthropicCompletionProvider(modelName || 'claude-instant-1', providerOptions);
        }
        else if (anthropic_1.AnthropicCompletionProvider.ANTHROPIC_COMPLETION_MODELS.includes(modelType)) {
            return new anthropic_1.AnthropicCompletionProvider(modelType, providerOptions);
        }
        else {
            throw new Error(`Unknown Anthropic model type: ${modelType}. Use one of the following providers: anthropic:completion:<model name>`);
        }
    }
    else if (providerPath?.startsWith('bedrock:')) {
        const splits = providerPath.split(':');
        const modelType = splits[1];
        const modelName = splits.slice(2).join(':');
        if (modelType === 'completion') {
            return new bedrock_1.AwsBedrockCompletionProvider(modelName || 'anthropic.claude-v2', providerOptions);
        }
        else if (bedrock_1.AwsBedrockCompletionProvider.AWS_BEDROCK_COMPLETION_MODELS.includes(modelType)) {
            return new bedrock_1.AwsBedrockCompletionProvider(modelType, providerOptions);
        }
        else {
            throw new Error(`Unknown Amazon Bedrock model type: ${modelType}. Use one of the following providers: bedrock:completion:<model name>`);
        }
    }
    else if (providerPath?.startsWith('huggingface:') || providerPath?.startsWith('hf:')) {
        const splits = providerPath.split(':');
        if (splits.length < 3) {
            throw new Error(`Invalid Huggingface provider path: ${providerPath}. Use one of the following providers: huggingface:feature-extraction:<model name>, huggingface:text-generation:<model name>`);
        }
        const modelName = splits.slice(2).join(':');
        if (splits[1] === 'feature-extraction') {
            return new huggingface_1.HuggingfaceFeatureExtractionProvider(modelName, providerOptions);
        }
        else if (splits[1] === 'sentence-similarity') {
            return new huggingface_1.HuggingfaceSentenceSimilarityProvider(modelName, providerOptions);
        }
        else if (splits[1] === 'text-generation') {
            return new huggingface_1.HuggingfaceTextGenerationProvider(modelName, providerOptions);
        }
        else if (splits[1] === 'text-classification') {
            return new huggingface_1.HuggingfaceTextClassificationProvider(modelName, providerOptions);
        }
        else {
            throw new Error(`Invalid Huggingface provider path: ${providerPath}. Use one of the following providers: huggingface:feature-extraction:<model name>, huggingface:text-generation:<model name>`);
        }
    }
    else if (providerPath?.startsWith('replicate:')) {
        const splits = providerPath.split(':');
        const modelName = splits.slice(1).join(':');
        return new replicate_1.ReplicateProvider(modelName, providerOptions);
    }
    if (providerPath.startsWith('webhook:')) {
        const webhookUrl = providerPath.substring('webhook:'.length);
        return new webhook_1.WebhookProvider(webhookUrl, providerOptions);
    }
    else if (providerPath === 'llama' || providerPath.startsWith('llama:')) {
        const modelName = providerPath.split(':')[1];
        return new llama_1.LlamaProvider(modelName, providerOptions);
    }
    else if (providerPath.startsWith('ollama:embeddings:') ||
        providerPath.startsWith('ollama:embedding:')) {
        const modelName = providerPath.split(':')[2];
        return new ollama_1.OllamaEmbeddingProvider(modelName, providerOptions);
    }
    else if (providerPath.startsWith('ollama:')) {
        const splits = providerPath.split(':');
        const firstPart = splits[1];
        if (firstPart === 'chat') {
            const modelName = splits.slice(2).join(':');
            return new ollama_1.OllamaChatProvider(modelName, providerOptions);
        }
        else if (firstPart === 'completion') {
            const modelName = splits.slice(2).join(':');
            return new ollama_1.OllamaCompletionProvider(modelName, providerOptions);
        }
        else {
            // Default to completion provider
            const modelName = splits.slice(1).join(':');
            return new ollama_1.OllamaCompletionProvider(modelName, providerOptions);
        }
    }
    else if (providerPath.startsWith('palm:') || providerPath.startsWith('google:')) {
        const modelName = providerPath.split(':')[1];
        return new palm_1.PalmChatProvider(modelName, providerOptions);
    }
    else if (providerPath.startsWith('vertex')) {
        const modelName = providerPath.split(':')[1];
        return new vertex_1.VertexChatProvider(modelName, providerOptions);
    }
    else if (providerPath.startsWith('mistral:')) {
        const modelName = providerPath.split(':')[1];
        return new mistral_1.MistralChatCompletionProvider(modelName, providerOptions);
    }
    else if (providerPath.startsWith('cohere:')) {
        const modelName = providerPath.split(':')[1];
        return new cohere_1.CohereChatCompletionProvider(modelName, providerOptions);
    }
    else if (providerPath?.startsWith('localai:')) {
        const splits = providerPath.split(':');
        const modelType = splits[1];
        const modelName = splits[2];
        if (modelType === 'chat') {
            return new localai_1.LocalAiChatProvider(modelName, providerOptions);
        }
        else if (modelType === 'completion') {
            return new localai_1.LocalAiCompletionProvider(modelName, providerOptions);
        }
        else if (modelType === 'embedding' || modelType === 'embeddings') {
            return new localai_1.LocalAiEmbeddingProvider(modelName, providerOptions);
        }
        else {
            return new localai_1.LocalAiChatProvider(modelType, providerOptions);
        }
    }
    // Load custom module
    const CustomApiProvider = (await Promise.resolve(`${path_1.default.join(process.cwd(), providerPath)}`).then(s => __importStar(require(s)))).default;
    return new CustomApiProvider(options);
}
exports.loadApiProvider = loadApiProvider;
exports.default = {
    OpenAiCompletionProvider: openai_1.OpenAiCompletionProvider,
    OpenAiChatCompletionProvider: openai_1.OpenAiChatCompletionProvider,
    OpenAiAssistantProvider: openai_1.OpenAiAssistantProvider,
    AnthropicCompletionProvider: anthropic_1.AnthropicCompletionProvider,
    ReplicateProvider: replicate_1.ReplicateProvider,
    LocalAiCompletionProvider: localai_1.LocalAiCompletionProvider,
    LocalAiChatProvider: localai_1.LocalAiChatProvider,
    loadApiProvider,
};
//# sourceMappingURL=providers.js.map