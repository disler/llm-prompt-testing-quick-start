"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnthropicCompletionProvider = void 0;
const sdk_1 = __importDefault(require("@anthropic-ai/sdk"));
const logger_1 = __importDefault(require("../logger"));
const cache_1 = require("../cache");
class AnthropicCompletionProvider {
    constructor(modelName, options = {}) {
        const { config, id, env } = options;
        this.modelName = modelName;
        this.apiKey = config?.apiKey || env?.ANTHROPIC_API_KEY || process.env.ANTHROPIC_API_KEY;
        this.anthropic = new sdk_1.default({ apiKey: this.apiKey });
        this.config = config || {};
        this.id = id ? () => id : this.id;
    }
    id() {
        return `anthropic:${this.modelName}`;
    }
    toString() {
        return `[Anthropic Provider ${this.modelName}]`;
    }
    async callApi(prompt) {
        if (!this.apiKey) {
            throw new Error('Anthropic API key is not set. Set the ANTHROPIC_API_KEY environment variable or add `apiKey` to the provider config.');
        }
        let stop;
        try {
            stop = process.env.ANTHROPIC_STOP
                ? JSON.parse(process.env.ANTHROPIC_STOP)
                : ['<|im_end|>', '<|endoftext|>'];
        }
        catch (err) {
            throw new Error(`ANTHROPIC_STOP is not a valid JSON string: ${err}`);
        }
        const params = {
            model: this.modelName,
            prompt: `${sdk_1.default.HUMAN_PROMPT} ${prompt} ${sdk_1.default.AI_PROMPT}`,
            max_tokens_to_sample: this.config?.max_tokens_to_sample || parseInt(process.env.ANTHROPIC_MAX_TOKENS || '1024'),
            temperature: this.config.temperature ?? parseFloat(process.env.ANTHROPIC_TEMPERATURE || '0'),
            stop_sequences: stop,
        };
        logger_1.default.debug(`Calling Anthropic API: ${JSON.stringify(params)}`);
        const cache = await (0, cache_1.getCache)();
        const cacheKey = `anthropic:${JSON.stringify(params)}`;
        if ((0, cache_1.isCacheEnabled)()) {
            // Try to get the cached response
            const cachedResponse = await cache.get(cacheKey);
            if (cachedResponse) {
                logger_1.default.debug(`Returning cached response for ${prompt}: ${cachedResponse}`);
                return {
                    output: JSON.parse(cachedResponse),
                    tokenUsage: {},
                };
            }
        }
        let response;
        try {
            response = await this.anthropic.completions.create(params);
        }
        catch (err) {
            return {
                error: `API call error: ${String(err)}`,
            };
        }
        logger_1.default.debug(`\tAnthropic API response: ${JSON.stringify(response)}`);
        if ((0, cache_1.isCacheEnabled)()) {
            try {
                await cache.set(cacheKey, JSON.stringify(response.completion));
            }
            catch (err) {
                logger_1.default.error(`Failed to cache response: ${String(err)}`);
            }
        }
        try {
            return {
                output: response.completion,
                tokenUsage: {}, // TODO: add token usage once Anthropic API supports it
            };
        }
        catch (err) {
            return {
                error: `API response error: ${String(err)}: ${JSON.stringify(response)}`,
            };
        }
    }
}
exports.AnthropicCompletionProvider = AnthropicCompletionProvider;
AnthropicCompletionProvider.ANTHROPIC_COMPLETION_MODELS = [
    'claude-1',
    'claude-1-100k',
    'claude-instant-1',
    'claude-instant-1.2',
    'claude-instant-1-100k',
    'claude-2',
    'claude-2.1',
];
//# sourceMappingURL=anthropic.js.map