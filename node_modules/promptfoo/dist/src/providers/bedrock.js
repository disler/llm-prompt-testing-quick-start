"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsBedrockCompletionProvider = void 0;
const sdk_1 = __importDefault(require("@anthropic-ai/sdk"));
const logger_1 = __importDefault(require("../logger"));
const cache_1 = require("../cache");
const BEDROCK_MODEL = {
    CLAUDE: {
        params: (config, prompt, stop) => ({
            prompt: `${sdk_1.default.HUMAN_PROMPT} ${prompt} ${sdk_1.default.AI_PROMPT}`,
            max_tokens_to_sample: config?.max_tokens_to_sample || parseInt(process.env.AWS_BEDROCK_MAX_TOKENS || '1024'),
            temperature: config.temperature ?? parseFloat(process.env.AWS_BEDROCK_TEMPERATURE || '0'),
            stop_sequences: stop,
        }),
        output: (responseJson) => {
            return responseJson?.completion;
        },
    },
    TITAN_TEXT: {
        params: (config, prompt, stop) => ({
            inputText: prompt,
            textGenerationConfig: {
                maxTokenCount: config?.textGenerationConfig?.maxTokenCount || parseInt(process.env.AWS_BEDROCK_MAX_TOKENS || '1024'),
                temperature: config?.textGenerationConfig?.temperature || parseFloat(process.env.AWS_BEDROCK_TEMPERATURE || '0'),
                topP: config?.textGenerationConfig?.topP || parseFloat(process.env.AWS_BEDROCK_TOP_P || '1'),
                stopSequences: config?.textGenerationConfig?.stopSequences || stop,
            }
        }),
        output: (responseJson) => {
            return responseJson?.results[0]?.outputText;
        },
    }
};
const AWS_BEDROCK_MODELS = {
    'anthropic.claude-instant-v1': BEDROCK_MODEL.CLAUDE,
    'anthropic.claude-v1': BEDROCK_MODEL.CLAUDE,
    'anthropic.claude-v2': BEDROCK_MODEL.CLAUDE,
    'anthropic.claude-v2.1': BEDROCK_MODEL.CLAUDE,
    'amazon.titan-text-lite-v1': BEDROCK_MODEL.TITAN_TEXT,
    'amazon.titan-text-express-v1': BEDROCK_MODEL.TITAN_TEXT,
};
class AwsBedrockCompletionProvider {
    constructor(modelName, options = {}) {
        const { config, id, env } = options;
        this.env = env;
        this.modelName = modelName;
        this.config = config || {};
        this.id = id ? () => id : this.id;
    }
    id() {
        return `bedrock:${this.modelName}`;
    }
    async getBedrockInstance() {
        if (!this.bedrock) {
            try {
                const { BedrockRuntime } = await Promise.resolve().then(() => __importStar(require('@aws-sdk/client-bedrock-runtime')));
                this.bedrock = new BedrockRuntime({ region: this.getRegion() });
            }
            catch (err) {
                throw new Error('The @aws-sdk/client-bedrock-runtime package is required as a peer dependency. Please install it in your project or globally.');
            }
        }
        return this.bedrock;
    }
    toString() {
        return `[Amazon Bedrock Provider ${this.modelName}]`;
    }
    getRegion() {
        return (this.config?.region ||
            this.env?.AWS_BEDROCK_REGION ||
            process.env.AWS_BEDROCK_REGION ||
            'us-west-2');
    }
    async callApi(prompt) {
        let stop;
        try {
            stop = process.env.AWS_BEDROCK_STOP
                ? JSON.parse(process.env.AWS_BEDROCK_STOP)
                : ['<|im_end|>', '<|endoftext|>'];
        }
        catch (err) {
            throw new Error(`BEDROCK_STOP is not a valid JSON string: ${err}`);
        }
        let model = AWS_BEDROCK_MODELS[this.modelName];
        if (!model) {
            logger_1.default.warn(`Unknown Amazon Bedrock model: ${this.modelName}. Assuming its API is Claude-like.`);
            model = BEDROCK_MODEL.CLAUDE;
        }
        const params = model.params(this.config, prompt, stop);
        logger_1.default.debug(`Calling Amazon Bedrock API: ${JSON.stringify(params)}`);
        const cache = await (0, cache_1.getCache)();
        const cacheKey = `bedrock:${JSON.stringify(params)}`;
        if ((0, cache_1.isCacheEnabled)()) {
            // Try to get the cached response
            const cachedResponse = await cache.get(cacheKey);
            if (cachedResponse) {
                logger_1.default.debug(`Returning cached response for ${prompt}: ${cachedResponse}`);
                return {
                    output: model.output(JSON.parse(cachedResponse)),
                    tokenUsage: {},
                };
            }
        }
        const bedrockInstance = await this.getBedrockInstance();
        let response;
        try {
            response = await bedrockInstance.invokeModel({
                body: JSON.stringify(params),
                modelId: this.modelName,
                accept: 'application/json',
                contentType: 'application/json',
            });
        }
        catch (err) {
            return {
                error: `API call error: ${String(err)}`,
            };
        }
        logger_1.default.debug(`\tAmazon Bedrock API response: ${JSON.parse(response.body.transformToString())}`);
        if ((0, cache_1.isCacheEnabled)()) {
            try {
                await cache.set(cacheKey, response.body.transformToString());
            }
            catch (err) {
                logger_1.default.error(`Failed to cache response: ${String(err)}`);
            }
        }
        try {
            return {
                output: model.output(JSON.parse(response.body.transformToString())),
                tokenUsage: {}, // TODO: add token usage once Amazon Bedrock API supports it
            };
        }
        catch (err) {
            return {
                error: `API response error: ${String(err)}: ${JSON.stringify(response)}`,
            };
        }
    }
}
exports.AwsBedrockCompletionProvider = AwsBedrockCompletionProvider;
AwsBedrockCompletionProvider.AWS_BEDROCK_COMPLETION_MODELS = Object.keys(AWS_BEDROCK_MODELS);
//# sourceMappingURL=bedrock.js.map