"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MistralChatCompletionProvider = void 0;
const logger_1 = __importDefault(require("../logger"));
const cache_1 = require("../cache");
const shared_1 = require("./shared");
function getTokenUsage(data, cached) {
    if (data.usage) {
        if (cached) {
            return { cached: data.usage.total_tokens, total: data.usage.total_tokens };
        }
        else {
            return {
                total: data.usage.total_tokens,
                prompt: data.usage.prompt_tokens || 0,
                completion: data.usage.completion_tokens || 0,
            };
        }
    }
    return {};
}
function calculateCost(modelName, config, promptTokens, completionTokens) {
    if (!promptTokens || !completionTokens) {
        return undefined;
    }
    const model = [
        ...MistralChatCompletionProvider.MISTRAL_CHAT_MODELS,
    ].find((m) => m.id === modelName);
    if (!model || !model.cost) {
        return undefined;
    }
    const inputCost = config.cost ?? model.cost.input;
    const outputCost = config.cost ?? model.cost.output;
    return inputCost * promptTokens + outputCost * completionTokens || undefined;
}
class MistralChatCompletionProvider {
    constructor(modelName, options = {}) {
        if (!MistralChatCompletionProvider.MISTRAL_CHAT_MODELS_NAMES.includes(modelName)) {
            logger_1.default.warn(`Using unknown Mistral chat model: ${modelName}`);
        }
        const { id, config, env } = options;
        this.env = env;
        this.modelName = modelName;
        this.id = id ? () => id : this.id;
        this.config = config || {};
    }
    id() {
        return `mistral:${this.modelName}`;
    }
    toString() {
        return `[Mistral Provider ${this.modelName}]`;
    }
    getApiKey() {
        return this.config.apiKey || this.env?.MISTRAL_API_KEY || process.env.MISTRAL_API_KEY;
    }
    async callApi(prompt) {
        if (!this.getApiKey()) {
            throw new Error('Mistra API key is not set. Set the MISTRAL_API_KEY environment variable or add `apiKey` to the provider config.');
        }
        const messages = (0, shared_1.parseChatPrompt)(prompt, [{ role: 'user', content: prompt }]);
        const body = {
            model: this.modelName,
            messages: messages,
            temperature: this.config?.temperature,
            top_p: this.config?.top_p || 1,
            max_tokens: this.config?.max_tokens || 1024,
            safe_prompt: this.config?.safe_prompt || false,
            random_seed: this.config?.random_seed || null,
        };
        const url = 'https://api.mistral.ai/v1/chat/completions';
        logger_1.default.debug(`Mistral API request: ${url} ${JSON.stringify(body)}`);
        let data, cached = false;
        try {
            ({ data, cached } = (await (0, cache_1.fetchWithCache)(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.getApiKey()}`,
                },
                body: JSON.stringify(body),
            }, shared_1.REQUEST_TIMEOUT_MS)));
        }
        catch (err) {
            return {
                error: `API call error: ${String(err)}`,
            };
        }
        logger_1.default.debug(`Mistral API response: ${JSON.stringify(data)}`);
        if (data.error) {
            return {
                error: `API call error: ${data.error}`,
            };
        }
        if (!data.choices[0] && !data.choices[0].message.content) {
            return {
                error: `Malformed response data: ${JSON.stringify(data)}`,
            };
        }
        let content;
        if (this.config?.fix_json) {
            // Mistral is often messing up JSON responses. This fixes the output to allow for the tests to pass.
            content = data.choices[0].message.content.replace(/\\_/g, "_").replace(/\\\*/g, "*");
        }
        else {
            content = data.choices[0].message.content;
        }
        return {
            output: content,
            tokenUsage: getTokenUsage(data, cached),
            cached,
            cost: calculateCost(this.modelName, this.config, data.usage?.prompt_tokens, data.usage?.completion_tokens),
        };
    }
}
exports.MistralChatCompletionProvider = MistralChatCompletionProvider;
MistralChatCompletionProvider.MISTRAL_CHAT_MODELS = [
    ...['mistral-tiny'].map((model) => ({
        id: model,
        cost: {
            input: 0.00015 / 1000,
            output: 0.00045 / 1000,
        },
    })),
    ...['mistral-small'].map((model) => ({
        id: model,
        cost: {
            input: 0.00064 / 1000,
            output: 0.00193 / 1000,
        },
    })),
    ...['mistral-medium'].map((model) => ({
        id: model,
        cost: {
            input: 0.00269 / 1000,
            output: 0.00806 / 1000,
        },
    }))
];
MistralChatCompletionProvider.MISTRAL_CHAT_MODELS_NAMES = MistralChatCompletionProvider.MISTRAL_CHAT_MODELS.map((model) => model.id);
//# sourceMappingURL=mistral.js.map