"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapTable = exports.generateTable = void 0;
const cli_table3_1 = __importDefault(require("cli-table3"));
const chalk_1 = __importDefault(require("chalk"));
function ellipsize(str, maxLen) {
    if (str.length > maxLen) {
        return str.slice(0, maxLen - 3) + '...';
    }
    return str;
}
function generateTable(summary, tableCellMaxLength = 250, maxRows = 25) {
    const maxWidth = process.stdout.columns ? process.stdout.columns - 10 : 120;
    const head = summary.table.head;
    const headLength = head.prompts.length + head.vars.length;
    const allProvidersSame = head.prompts.every((p) => p.provider === head.prompts[0].provider);
    const table = new cli_table3_1.default({
        head: [
            ...head.vars,
            ...head.prompts.map((prompt) => allProvidersSame ? prompt.display : `[${prompt.provider}] ${prompt.display}`),
        ].map((h) => ellipsize(h, tableCellMaxLength)),
        colWidths: Array(headLength).fill(Math.floor(maxWidth / headLength)),
        wordWrap: true,
        wrapOnWordBoundary: false,
        style: {
            head: ['blue', 'bold'],
        },
    });
    // Skip first row (header) and add the rest. Color PASS/FAIL
    for (const row of summary.table.body.slice(0, maxRows)) {
        table.push([
            ...row.vars.map((v) => ellipsize(v, tableCellMaxLength)),
            ...row.outputs.map(({ pass, score, text }) => {
                text = ellipsize(text, tableCellMaxLength);
                if (pass) {
                    return chalk_1.default.green('[PASS] ') + text;
                }
                else if (!pass) {
                    // color everything red up until '---'
                    return (chalk_1.default.red('[FAIL] ') +
                        text
                            .split('---')
                            .map((c, idx) => (idx === 0 ? chalk_1.default.red.bold(c) : c))
                            .join('---'));
                }
                return text;
            }),
        ]);
    }
    return table;
}
exports.generateTable = generateTable;
function wrapTable(rows) {
    const maxWidth = process.stdout.columns ? process.stdout.columns - 10 : 120;
    const head = Object.keys(rows[0]);
    const table = new cli_table3_1.default({
        head,
        colWidths: Array(head.length).fill(Math.floor(maxWidth / head.length)),
        wordWrap: true,
        wrapOnWordBoundary: true,
    });
    for (const row of rows) {
        table.push(Object.values(row));
    }
    return table;
}
exports.wrapTable = wrapTable;
//# sourceMappingURL=table.js.map