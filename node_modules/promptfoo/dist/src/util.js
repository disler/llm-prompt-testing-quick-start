"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformOutput = exports.printBorder = exports.getNunjucksEngine = exports.readFilters = exports.getEvalsWithPredicate = exports.getEvalFromHash = exports.getEvals = exports.getDatasetFromHash = exports.getPromptFromHash = exports.getTestCasesWithPredicate = exports.getTestCases = exports.getPromptsWithPredicate = exports.getPrompts = exports.sha256 = exports.getPromptsForTestCasesHash = exports.getPromptsForTestCases = exports.readLatestResults = exports.updateResult = exports.readResult = exports.dateToFilename = exports.filenameToDate = exports.cleanupOldResults = exports.listPreviousResults = exports.listPreviousResultFilenames = exports.writeLatestResults = exports.getLatestResultsPath = exports.setConfigDirectoryPath = exports.getConfigDirectoryPath = exports.writeOutput = exports.writeMultipleOutputs = exports.readConfigs = exports.readConfig = exports.dereferenceConfig = exports.maybeReadConfig = exports.maybeRecordFirstRun = exports.readGlobalConfig = exports.resetGlobalConfig = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const crypto_1 = require("crypto");
const json_schema_ref_parser_1 = __importDefault(require("@apidevtools/json-schema-ref-parser"));
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const nunjucks_1 = __importDefault(require("nunjucks"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const sync_1 = require("csv-stringify/sync");
const glob_1 = require("glob");
const logger_1 = __importDefault(require("./logger"));
const esm_1 = require("./esm");
const testCases_1 = require("./testCases");
let globalConfigCache = null;
function resetGlobalConfig() {
    globalConfigCache = null;
}
exports.resetGlobalConfig = resetGlobalConfig;
function readGlobalConfig() {
    if (!globalConfigCache) {
        const configDir = getConfigDirectoryPath();
        const configFilePath = path.join(configDir, 'promptfoo.yaml');
        if (fs.existsSync(configFilePath)) {
            globalConfigCache = js_yaml_1.default.load(fs.readFileSync(configFilePath, 'utf-8'));
        }
        else {
            if (!fs.existsSync(configDir)) {
                fs.mkdirSync(configDir, { recursive: true });
            }
            globalConfigCache = { hasRun: false };
            fs.writeFileSync(configFilePath, js_yaml_1.default.dump(globalConfigCache));
        }
    }
    return globalConfigCache;
}
exports.readGlobalConfig = readGlobalConfig;
function maybeRecordFirstRun() {
    // Return true if first run
    try {
        const config = readGlobalConfig();
        if (!config.hasRun) {
            config.hasRun = true;
            fs.writeFileSync(path.join(getConfigDirectoryPath(), 'promptfoo.yaml'), js_yaml_1.default.dump(config));
            return true;
        }
        return false;
    }
    catch (err) {
        return false;
    }
}
exports.maybeRecordFirstRun = maybeRecordFirstRun;
async function maybeReadConfig(configPath) {
    if (!fs.existsSync(configPath)) {
        return undefined;
    }
    return readConfig(configPath);
}
exports.maybeReadConfig = maybeReadConfig;
async function dereferenceConfig(rawConfig) {
    if (process.env.PROMPTFOO_DISABLE_REF_PARSER) {
        return rawConfig;
    }
    // Track and delete tools[i].function for each tool, preserving the rest of the properties
    // https://github.com/promptfoo/promptfoo/issues/364
    // Remove parameters from functions and tools to prevent dereferencing
    const extractFunctionParameters = (functions) => {
        return functions.map((func) => {
            const { parameters } = func;
            delete func.parameters;
            return { parameters };
        });
    };
    const extractToolParameters = (tools) => {
        return tools.map((tool) => {
            const { parameters } = tool.function || {};
            if (tool.function?.parameters) {
                delete tool.function.parameters;
            }
            return { parameters };
        });
    };
    // Restore parameters to functions and tools after dereferencing
    const restoreFunctionParameters = (functions, parametersList) => {
        functions.forEach((func, index) => {
            if (parametersList[index]?.parameters) {
                func.parameters = parametersList[index].parameters;
            }
        });
    };
    const restoreToolParameters = (tools, parametersList) => {
        tools.forEach((tool, index) => {
            if (parametersList[index]?.parameters) {
                tool.function = tool.function || {};
                tool.function.parameters = parametersList[index].parameters;
            }
        });
    };
    let functionsParametersList = [];
    let toolsParametersList = [];
    if (Array.isArray(rawConfig.providers)) {
        rawConfig.providers.forEach((provider, providerIndex) => {
            if (typeof provider === 'string')
                return;
            if (!provider.config) {
                // Handle when provider is a map
                provider = Object.values(provider)[0];
            }
            if (provider.config?.functions) {
                functionsParametersList[providerIndex] = extractFunctionParameters(provider.config.functions);
            }
            if (provider.config?.tools) {
                toolsParametersList[providerIndex] = extractToolParameters(provider.config.tools);
            }
        });
    }
    // Dereference JSON
    const config = (await json_schema_ref_parser_1.default.dereference(rawConfig));
    // Restore functions and tools parameters
    if (Array.isArray(config.providers)) {
        config.providers.forEach((provider, index) => {
            if (typeof provider === 'string')
                return;
            if (!provider.config) {
                // Handle when provider is a map
                provider = Object.values(provider)[0];
            }
            if (functionsParametersList[index]) {
                provider.config.functions = provider.config.functions || [];
                restoreFunctionParameters(provider.config.functions, functionsParametersList[index]);
            }
            if (toolsParametersList[index]) {
                provider.config.tools = provider.config.tools || [];
                restoreToolParameters(provider.config.tools, toolsParametersList[index]);
            }
        });
    }
    return config;
}
exports.dereferenceConfig = dereferenceConfig;
async function readConfig(configPath) {
    const ext = path.parse(configPath).ext;
    switch (ext) {
        case '.json':
        case '.yaml':
        case '.yml':
            let rawConfig = js_yaml_1.default.load(fs.readFileSync(configPath, 'utf-8'));
            return dereferenceConfig(rawConfig);
        case '.js':
            return require(configPath);
        default:
            throw new Error(`Unsupported configuration file format: ${ext}`);
    }
}
exports.readConfig = readConfig;
async function readConfigs(configPaths) {
    const configs = [];
    for (const configPath of configPaths) {
        const globPaths = (0, glob_1.globSync)(configPath);
        for (const globPath of globPaths) {
            const config = await readConfig(globPath);
            configs.push(config);
        }
    }
    const providers = [];
    const seenProviders = new Set();
    configs.forEach((config) => {
        (0, tiny_invariant_1.default)(typeof config.providers !== 'function', 'Providers cannot be a function for multiple configs');
        if (typeof config.providers === 'string') {
            if (!seenProviders.has(config.providers)) {
                providers.push(config.providers);
                seenProviders.add(config.providers);
            }
        }
        else if (Array.isArray(config.providers)) {
            config.providers.forEach((provider) => {
                if (!seenProviders.has(JSON.stringify(provider))) {
                    providers.push(provider);
                    seenProviders.add(JSON.stringify(provider));
                }
            });
        }
    });
    const tests = [];
    configs.forEach(async (config) => {
        if (typeof config.tests === 'string') {
            const newTests = await (0, testCases_1.readTests)(config.tests, path.dirname(configPaths[0]));
            tests.push(...newTests);
        }
        else if (Array.isArray(config.tests)) {
            tests.push(...config.tests);
        }
    });
    const configsAreStringOrArray = configs.every((config) => typeof config.prompts === 'string' || Array.isArray(config.prompts));
    const configsAreObjects = configs.every((config) => typeof config.prompts === 'object');
    let prompts = configsAreStringOrArray ? [] : {};
    const makeAbsolute = (configPath, relativePath) => {
        if (relativePath.startsWith('file://')) {
            relativePath =
                'file://' + path.resolve(path.dirname(configPath), relativePath.slice('file://'.length));
        }
        return relativePath;
    };
    configs.forEach((config, idx) => {
        if (typeof config.prompts === 'string') {
            (0, tiny_invariant_1.default)(Array.isArray(prompts), 'Cannot mix string and map-type prompts');
            config.prompts = makeAbsolute(configPaths[idx], config.prompts);
            prompts.push(config.prompts);
        }
        else if (Array.isArray(config.prompts)) {
            (0, tiny_invariant_1.default)(Array.isArray(prompts), 'Cannot mix configs with map and array-type prompts');
            config.prompts = config.prompts.map((prompt) => makeAbsolute(configPaths[idx], prompt));
            prompts.push(...config.prompts);
        }
        else {
            // Object format such as { 'prompts/prompt1.txt': 'foo', 'prompts/prompt2.txt': 'bar' }
            (0, tiny_invariant_1.default)(typeof prompts === 'object', 'Cannot mix configs with map and array-type prompts');
            prompts = { ...prompts, ...config.prompts };
        }
    });
    // Combine all configs into a single UnifiedConfig
    const combinedConfig = {
        description: configs.map((config) => config.description).join(', '),
        providers,
        prompts,
        tests,
        scenarios: configs.flatMap((config) => config.scenarios || []),
        defaultTest: configs.reduce((prev, curr) => {
            return {
                ...prev,
                ...curr.defaultTest,
                vars: { ...prev?.vars, ...curr.defaultTest?.vars },
                assert: [...(prev?.assert || []), ...(curr.defaultTest?.assert || [])],
                options: { ...prev?.options, ...curr.defaultTest?.options },
            };
        }, {}),
        nunjucksFilters: configs.reduce((prev, curr) => ({ ...prev, ...curr.nunjucksFilters }), {}),
        env: configs.reduce((prev, curr) => ({ ...prev, ...curr.env }), {}),
        evaluateOptions: configs.reduce((prev, curr) => ({ ...prev, ...curr.evaluateOptions }), {}),
        commandLineOptions: configs.reduce((prev, curr) => ({ ...prev, ...curr.commandLineOptions }), {}),
        sharing: !configs.some((config) => config.sharing === false),
    };
    return combinedConfig;
}
exports.readConfigs = readConfigs;
function writeMultipleOutputs(outputPaths, results, config, shareableUrl) {
    for (const outputPath of outputPaths) {
        writeOutput(outputPath, results, config, shareableUrl);
    }
}
exports.writeMultipleOutputs = writeMultipleOutputs;
function writeOutput(outputPath, results, config, shareableUrl) {
    const outputExtension = outputPath.split('.').pop()?.toLowerCase();
    const outputToSimpleString = (output) => {
        const passFailText = output.pass ? '[PASS]' : '[FAIL]';
        const namedScoresText = Object.entries(output.namedScores)
            .map(([name, value]) => `${name}: ${value.toFixed(2)}`)
            .join(', ');
        const scoreText = namedScoresText.length > 0
            ? `(${output.score.toFixed(2)}, ${namedScoresText})`
            : `(${output.score.toFixed(2)})`;
        const gradingResultText = output.gradingResult ? `Reason: ${output.gradingResult.reason}` : '';
        return `${passFailText} ${scoreText}

${output.text}

${gradingResultText}`.trim();
    };
    // Ensure the directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    if (outputExtension === 'csv') {
        const csvOutput = (0, sync_1.stringify)([
            [
                ...results.table.head.vars,
                ...results.table.head.prompts.map((prompt) => JSON.stringify(prompt)),
            ],
            ...results.table.body.map((row) => [...row.vars, ...row.outputs.map(outputToSimpleString)]),
        ]);
        fs.writeFileSync(outputPath, csvOutput);
    }
    else if (outputExtension === 'json') {
        fs.writeFileSync(outputPath, JSON.stringify({ results, config, shareableUrl }, null, 2));
    }
    else if (outputExtension === 'yaml' || outputExtension === 'yml' || outputExtension === 'txt') {
        fs.writeFileSync(outputPath, js_yaml_1.default.dump({ results, config, shareableUrl }));
    }
    else if (outputExtension === 'html') {
        const template = fs.readFileSync(`${(0, esm_1.getDirectory)()}/tableOutput.html`, 'utf-8');
        const table = [
            [...results.table.head.vars, ...results.table.head.prompts.map((prompt) => prompt.display)],
            ...results.table.body.map((row) => [...row.vars, ...row.outputs.map(outputToSimpleString)]),
        ];
        const htmlOutput = getNunjucksEngine().renderString(template, {
            config,
            table,
            results: results.results,
        });
        fs.writeFileSync(outputPath, htmlOutput);
    }
    else {
        throw new Error(`Unsupported output file format ${outputExtension}, please use csv, txt, json, yaml, yml, html.`);
    }
}
exports.writeOutput = writeOutput;
let configDirectoryPath = process.env.PROMPTFOO_CONFIG_DIR;
function getConfigDirectoryPath() {
    return configDirectoryPath || path.join(os.homedir(), '.promptfoo');
}
exports.getConfigDirectoryPath = getConfigDirectoryPath;
function setConfigDirectoryPath(newPath) {
    configDirectoryPath = newPath;
}
exports.setConfigDirectoryPath = setConfigDirectoryPath;
function getLatestResultsPath() {
    return path.join(getConfigDirectoryPath(), 'output', 'latest.json');
}
exports.getLatestResultsPath = getLatestResultsPath;
function writeLatestResults(results, config) {
    const resultsDirectory = path.join(getConfigDirectoryPath(), 'output');
    // Replace hyphens with colons (Windows compatibility).
    const filename = dateToFilename(new Date());
    const newResultsPath = path.join(resultsDirectory, filename);
    const latestResultsPath = getLatestResultsPath();
    try {
        fs.mkdirSync(resultsDirectory, { recursive: true });
        const resultsFileData = {
            version: 2,
            createdAt: new Date().toISOString(),
            config,
            results,
        };
        fs.writeFileSync(newResultsPath, JSON.stringify(resultsFileData, null, 2));
        // Use copy instead of symlink to avoid issues with Windows permissions.
        try {
            // Backwards compatibility: delete old symlink.
            fs.unlinkSync(latestResultsPath);
        }
        catch { }
        fs.copyFileSync(newResultsPath, latestResultsPath);
        cleanupOldResults();
    }
    catch (err) {
        logger_1.default.error(`Failed to write latest results to ${newResultsPath}:\n${err}`);
    }
}
exports.writeLatestResults = writeLatestResults;
const resultsCache = {};
function listPreviousResultFilenames() {
    const directory = path.join(getConfigDirectoryPath(), 'output');
    const files = fs.readdirSync(directory);
    const resultsFiles = files.filter((file) => file.startsWith('eval-') && file.endsWith('.json'));
    return resultsFiles.sort((a, b) => {
        const statA = fs.statSync(path.join(directory, a));
        const statB = fs.statSync(path.join(directory, b));
        return statA.birthtime.getTime() - statB.birthtime.getTime(); // sort in ascending order
    });
}
exports.listPreviousResultFilenames = listPreviousResultFilenames;
function listPreviousResults() {
    const directory = path.join(getConfigDirectoryPath(), 'output');
    const sortedFiles = listPreviousResultFilenames();
    return sortedFiles.map((fileName) => {
        if (!resultsCache[fileName]) {
            try {
                const fileContents = fs.readFileSync(path.join(directory, fileName), 'utf8');
                const data = js_yaml_1.default.load(fileContents);
                resultsCache[fileName] = data;
            }
            catch (error) {
                logger_1.default.warn(`Failed to read results from ${fileName}:\n${error}`);
            }
        }
        return {
            fileName,
            description: resultsCache[fileName]?.config.description,
        };
    });
}
exports.listPreviousResults = listPreviousResults;
const RESULT_HISTORY_LENGTH = parseInt(process.env.RESULT_HISTORY_LENGTH || '', 10) || 100;
function cleanupOldResults(remaining = RESULT_HISTORY_LENGTH) {
    const sortedFilenames = listPreviousResultFilenames();
    for (let i = 0; i < sortedFilenames.length - remaining; i++) {
        fs.unlinkSync(path.join(getConfigDirectoryPath(), 'output', sortedFilenames[i]));
    }
}
exports.cleanupOldResults = cleanupOldResults;
function filenameToDate(filename) {
    const dateString = filename.slice('eval-'.length, filename.length - '.json'.length);
    // Replace hyphens with colons where necessary (Windows compatibility).
    const dateParts = dateString.split('T');
    const timePart = dateParts[1].replace(/-/g, ':');
    const formattedDateString = `${dateParts[0]}T${timePart}`;
    const date = new Date(formattedDateString);
    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZoneName: 'short',
    });
}
exports.filenameToDate = filenameToDate;
function dateToFilename(date) {
    return `eval-${date.toISOString().replace(/:/g, '-')}.json`;
}
exports.dateToFilename = dateToFilename;
function readResult(name) {
    const resultsDirectory = path.join(getConfigDirectoryPath(), 'output');
    const resultsPath = path.join(resultsDirectory, name);
    try {
        const result = JSON.parse(fs.readFileSync(fs.realpathSync(resultsPath), 'utf-8'));
        const createdAt = new Date(filenameToDate(name));
        return {
            id: sha256(JSON.stringify(result.config)),
            result,
            createdAt,
        };
    }
    catch (err) {
        logger_1.default.error(`Failed to read results from ${resultsPath}:\n${err}`);
    }
}
exports.readResult = readResult;
function updateResult(filename, newTable) {
    const resultsDirectory = path.join(getConfigDirectoryPath(), 'output');
    const safeFilename = path.basename(filename);
    const resultsPath = path.join(resultsDirectory, safeFilename);
    try {
        const evalData = JSON.parse(fs.readFileSync(resultsPath, 'utf-8'));
        evalData.results.table = newTable;
        fs.writeFileSync(resultsPath, JSON.stringify(evalData, null, 2));
        logger_1.default.info(`Updated results in ${resultsPath}`);
        const resultFilenames = listPreviousResultFilenames();
        if (filename === resultFilenames[resultFilenames.length - 1]) {
            // Overwite latest.json too
            fs.copyFileSync(resultsPath, getLatestResultsPath());
        }
    }
    catch (err) {
        logger_1.default.error(`Failed to update results in ${resultsPath}:\n${err}`);
    }
}
exports.updateResult = updateResult;
function readLatestResults() {
    return JSON.parse(fs.readFileSync(getLatestResultsPath(), 'utf-8'));
}
exports.readLatestResults = readLatestResults;
function getPromptsForTestCases(testCases) {
    const testCasesJson = JSON.stringify(testCases);
    const testCasesSha256 = sha256(testCasesJson);
    return getPromptsForTestCasesHash(testCasesSha256);
}
exports.getPromptsForTestCases = getPromptsForTestCases;
function getPromptsForTestCasesHash(testCasesSha256) {
    return getPromptsWithPredicate((result) => {
        const testsJson = JSON.stringify(result.config.tests);
        const hash = sha256(testsJson);
        return hash === testCasesSha256;
    });
}
exports.getPromptsForTestCasesHash = getPromptsForTestCasesHash;
function sha256(str) {
    return (0, crypto_1.createHash)('sha256').update(str).digest('hex');
}
exports.sha256 = sha256;
function getPrompts() {
    return getPromptsWithPredicate(() => true);
}
exports.getPrompts = getPrompts;
function getPromptsWithPredicate(predicate) {
    const resultFilenames = listPreviousResultFilenames();
    const groupedPrompts = {};
    for (const fileName of resultFilenames) {
        const file = readResult(fileName);
        if (!file) {
            continue;
        }
        const { result, createdAt } = file;
        if (result && predicate(result)) {
            for (const prompt of result.results.table.head.prompts) {
                const evalId = sha256(JSON.stringify(result.config));
                const promptId = sha256(prompt.raw);
                const datasetId = result.config.tests ? sha256(JSON.stringify(result.config.tests)) : '-';
                if (promptId in groupedPrompts) {
                    groupedPrompts[promptId].recentEvalDate = new Date(Math.max(groupedPrompts[promptId].recentEvalDate.getTime(), new Date(createdAt).getTime()));
                    groupedPrompts[promptId].count += 1;
                    groupedPrompts[promptId].evals.push({
                        id: evalId,
                        filePath: fileName,
                        datasetId,
                        metrics: prompt.metrics,
                    });
                }
                else {
                    groupedPrompts[promptId] = {
                        count: 1,
                        id: promptId,
                        prompt,
                        recentEvalDate: new Date(createdAt),
                        recentEvalId: evalId,
                        recentEvalFilepath: fileName,
                        evals: [
                            {
                                id: evalId,
                                filePath: fileName,
                                datasetId,
                                metrics: prompt.metrics,
                            },
                        ],
                    };
                }
            }
        }
    }
    return Object.values(groupedPrompts);
}
exports.getPromptsWithPredicate = getPromptsWithPredicate;
function getTestCases() {
    return getTestCasesWithPredicate(() => true);
}
exports.getTestCases = getTestCases;
function getTestCasesWithPredicate(predicate) {
    const resultFilenames = listPreviousResultFilenames();
    const groupedTestCases = {};
    for (const fileName of resultFilenames) {
        const file = readResult(fileName);
        if (!file) {
            continue;
        }
        const { result, createdAt } = file;
        const testCases = result?.config?.tests;
        if (testCases && predicate(result)) {
            const evalId = sha256(JSON.stringify(result.config));
            const datasetId = sha256(JSON.stringify(testCases));
            if (datasetId in groupedTestCases) {
                groupedTestCases[datasetId].recentEvalDate = new Date(Math.max(groupedTestCases[datasetId].recentEvalDate.getTime(), new Date(createdAt).getTime()));
                groupedTestCases[datasetId].count += 1;
                const newPrompts = result.results.table.head.prompts.map((prompt) => ({
                    id: sha256(prompt.raw),
                    prompt,
                    evalId,
                    evalFilepath: fileName,
                }));
                const promptsById = {};
                for (const prompt of groupedTestCases[datasetId].prompts.concat(newPrompts)) {
                    if (!(prompt.id in promptsById)) {
                        promptsById[prompt.id] = prompt;
                    }
                }
                groupedTestCases[datasetId].prompts = Object.values(promptsById);
            }
            else {
                const newPrompts = result.results.table.head.prompts.map((prompt) => ({
                    id: (0, crypto_1.createHash)('sha256').update(prompt.raw).digest('hex'),
                    prompt,
                    evalId,
                    evalFilepath: fileName,
                }));
                const promptsById = {};
                for (const prompt of newPrompts) {
                    if (!(prompt.id in promptsById)) {
                        promptsById[prompt.id] = prompt;
                    }
                }
                groupedTestCases[datasetId] = {
                    id: datasetId,
                    count: 1,
                    testCases,
                    recentEvalDate: new Date(createdAt),
                    recentEvalId: evalId,
                    recentEvalFilepath: fileName,
                    prompts: Object.values(promptsById),
                };
            }
        }
    }
    return Object.values(groupedTestCases);
}
exports.getTestCasesWithPredicate = getTestCasesWithPredicate;
function getPromptFromHash(hash) {
    const prompts = getPrompts();
    for (const prompt of prompts) {
        if (prompt.id.startsWith(hash)) {
            return prompt;
        }
    }
    return undefined;
}
exports.getPromptFromHash = getPromptFromHash;
function getDatasetFromHash(hash) {
    const datasets = getTestCases();
    for (const dataset of datasets) {
        if (dataset.id.startsWith(hash)) {
            return dataset;
        }
    }
    return undefined;
}
exports.getDatasetFromHash = getDatasetFromHash;
function getEvals() {
    return getEvalsWithPredicate(() => true);
}
exports.getEvals = getEvals;
function getEvalFromHash(hash) {
    const evals = getEvals();
    for (const eval_ of evals) {
        if (eval_.id.startsWith(hash)) {
            return eval_;
        }
    }
    return undefined;
}
exports.getEvalFromHash = getEvalFromHash;
function getEvalsWithPredicate(predicate) {
    const ret = [];
    const resultsFilenames = listPreviousResultFilenames();
    for (const fileName of resultsFilenames) {
        const file = readResult(fileName);
        if (!file) {
            continue;
        }
        const { result, createdAt } = file;
        if (result && predicate(result)) {
            const evalId = sha256(fileName + ':' + JSON.stringify(result.config));
            ret.push({
                id: evalId,
                filePath: fileName,
                date: createdAt,
                config: result.config,
                results: result.results,
            });
        }
    }
    return ret;
}
exports.getEvalsWithPredicate = getEvalsWithPredicate;
function readFilters(filters, basePath = '') {
    const ret = {};
    for (const [name, filterPath] of Object.entries(filters)) {
        const globPath = path.join(basePath, filterPath);
        const filePaths = (0, glob_1.globSync)(globPath);
        for (const filePath of filePaths) {
            const finalPath = path.resolve(filePath);
            const importedModule = require(finalPath);
            ret[name] = importedModule.default || importedModule;
        }
    }
    return ret;
}
exports.readFilters = readFilters;
function getNunjucksEngine(filters) {
    if (process.env.PROMPTFOO_DISABLE_TEMPLATING) {
        return {
            renderString: (template) => template,
        };
    }
    const env = nunjucks_1.default.configure({
        autoescape: false,
    });
    if (filters) {
        for (const [name, filter] of Object.entries(filters)) {
            env.addFilter(name, filter);
        }
    }
    return env;
}
exports.getNunjucksEngine = getNunjucksEngine;
function printBorder() {
    const border = '='.repeat((process.stdout.columns || 80) - 10);
    logger_1.default.info(border);
}
exports.printBorder = printBorder;
function transformOutput(code, output, context) {
    const postprocessFn = new Function('output', 'context', code.includes('\n') ? code : `return ${code}`);
    const ret = postprocessFn(output, context);
    if (output == null) {
        throw new Error(`Postprocess function did not return a value\n\n${code}`);
    }
    return ret;
}
exports.transformOutput = transformOutput;
//# sourceMappingURL=util.js.map