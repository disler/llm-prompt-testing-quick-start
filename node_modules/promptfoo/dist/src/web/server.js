"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startServer = void 0;
const fs_1 = __importDefault(require("fs"));
const node_path_1 = __importDefault(require("node:path"));
const node_readline_1 = __importDefault(require("node:readline"));
const node_http_1 = __importDefault(require("node:http"));
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const uuid_1 = require("uuid");
const debounce_1 = __importDefault(require("debounce"));
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const compression_1 = __importDefault(require("compression"));
const opener_1 = __importDefault(require("opener"));
const socket_io_1 = require("socket.io");
const index_1 = __importDefault(require("../index"));
const logger_1 = __importDefault(require("../logger"));
const esm_1 = require("../esm");
const util_1 = require("../util");
const testCases_1 = require("../testCases");
// Running jobs
const evalJobs = new Map();
// Prompts cache
let allPrompts = null;
function startServer(port = 15500, apiBaseUrl = '', skipConfirmation = false) {
    const app = (0, express_1.default)();
    const staticDir = node_path_1.default.join((0, esm_1.getDirectory)(), 'web', 'nextui');
    app.use((0, cors_1.default)());
    app.use((0, compression_1.default)());
    app.use(express_1.default.json({ limit: '100mb' }));
    app.use(express_1.default.urlencoded({ limit: '100mb', extended: true }));
    const httpServer = node_http_1.default.createServer(app);
    const io = new socket_io_1.Server(httpServer, {
        cors: {
            origin: '*',
        },
    });
    const latestJsonPath = (0, util_1.getLatestResultsPath)();
    const readLatestJson = () => {
        const data = fs_1.default.readFileSync(latestJsonPath, 'utf8');
        return JSON.parse(data);
    };
    io.on('connection', (socket) => {
        // Send the initial table data when a client connects
        socket.emit('init', readLatestJson());
        // Watch for changes to latest.json and emit the update event
        const watcher = (0, debounce_1.default)((curr, prev) => {
            if (curr.mtime !== prev.mtime) {
                socket.emit('update', readLatestJson());
                allPrompts = null;
            }
        }, 250);
        fs_1.default.watchFile(latestJsonPath, watcher);
        // Stop watching the file when the socket connection is closed
        socket.on('disconnect', () => {
            fs_1.default.unwatchFile(latestJsonPath, watcher);
        });
    });
    app.get('/results', (req, res) => {
        const previousResults = (0, util_1.listPreviousResults)();
        previousResults.reverse();
        res.json({
            data: previousResults.map((fileMeta) => {
                const dateString = (0, util_1.filenameToDate)(fileMeta.fileName);
                return {
                    id: fileMeta.fileName,
                    label: fileMeta.description ? `${fileMeta.description} (${dateString})` : dateString,
                };
            }),
        });
    });
    app.post('/api/eval/job', (req, res) => {
        const testSuite = req.body;
        const id = (0, uuid_1.v4)();
        evalJobs.set(id, { status: 'in-progress', progress: 0, total: 0, result: null });
        index_1.default
            .evaluate(Object.assign({}, testSuite, {
            writeLatestResults: true,
            sharing: testSuite.sharing ?? true,
        }), {
            eventSource: 'web',
            progressCallback: (progress, total) => {
                const job = evalJobs.get(id);
                (0, tiny_invariant_1.default)(job, 'Job not found');
                job.progress = progress;
                job.total = total;
                console.log(`[${id}] ${progress}/${total}`);
            },
        })
            .then((result) => {
            const job = evalJobs.get(id);
            (0, tiny_invariant_1.default)(job, 'Job not found');
            job.status = 'complete';
            job.result = result;
            console.log(`[${id}] Complete`);
        });
        res.json({ id });
    });
    app.get('/api/eval/job/:id', (req, res) => {
        const id = req.params.id;
        const job = evalJobs.get(id);
        if (!job) {
            res.status(404).json({ error: 'Job not found' });
            return;
        }
        if (job.status === 'complete') {
            res.json({ status: 'complete', result: job.result });
        }
        else {
            res.json({ status: 'in-progress', progress: job.progress, total: job.total });
        }
    });
    app.patch('/api/eval/:id', (req, res) => {
        const id = req.params.id;
        const evalTable = req.body.table;
        if (!id) {
            res.status(400).json({ error: 'Missing id' });
            return;
        }
        try {
            (0, util_1.updateResult)(id, evalTable);
            res.json({ message: 'Eval table updated successfully' });
        }
        catch (error) {
            res.status(500).json({ error: 'Failed to update eval table' });
        }
    });
    app.get('/results/:filename', (req, res) => {
        const filename = req.params.filename;
        const safeFilename = node_path_1.default.basename(filename);
        if (safeFilename !== filename ||
            !(0, util_1.listPreviousResultFilenames)()
                .includes(safeFilename)) {
            res.status(400).send('Invalid filename');
            return;
        }
        const file = (0, util_1.readResult)(safeFilename);
        if (!file) {
            res.status(404).send('Result not found');
            return;
        }
        res.json({ data: file.result });
    });
    app.get('/api/prompts', (req, res) => {
        if (allPrompts == null) {
            allPrompts = (0, util_1.getPrompts)();
        }
        res.json({ data: allPrompts });
    });
    app.get('/api/prompts/:sha256hash', (req, res) => {
        const sha256hash = req.params.sha256hash;
        const prompts = (0, util_1.getPromptsForTestCasesHash)(sha256hash);
        res.json({ data: prompts });
    });
    app.get('/api/datasets', (req, res) => {
        res.json({ data: (0, util_1.getTestCases)() });
    });
    app.get('/api/config', (req, res) => {
        res.json({
            apiBaseUrl: apiBaseUrl || '',
        });
    });
    app.post('/api/dataset/generate', async (req, res) => {
        const testSuite = {
            prompts: req.body.prompts,
            tests: req.body.tests,
            providers: [],
        };
        const results = await (0, testCases_1.synthesizeFromTestSuite)(testSuite, {});
        return {
            results,
        };
    });
    // Must come after the above routes (particularly /api/config) so it doesn't
    // overwrite dynamic routes.
    app.use(express_1.default.static(staticDir));
    httpServer.listen(port, () => {
        const url = `http://localhost:${port}`;
        logger_1.default.info(`Server running at ${url} and monitoring for new evals.`);
        const openUrl = async () => {
            try {
                logger_1.default.info('Press Ctrl+C to stop the server');
                await (0, opener_1.default)(url);
            }
            catch (err) {
                logger_1.default.error(`Failed to open browser: ${String(err)}`);
            }
        };
        if (skipConfirmation) {
            openUrl();
        }
        else {
            const rl = node_readline_1.default.createInterface({
                input: process.stdin,
                output: process.stdout,
            });
            rl.question('Open URL in browser? (y/N): ', async (answer) => {
                if (answer.toLowerCase().startsWith('y')) {
                    openUrl();
                }
                rl.close();
                logger_1.default.info('Press Ctrl+C to stop the server');
            });
        }
    });
}
exports.startServer = startServer;
//# sourceMappingURL=server.js.map